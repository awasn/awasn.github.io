<!doctype html><html lang=pl-pl><head><meta name=theme-color content="#405365"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.83.1"><meta name=description content="Konfiguracja struktury i uprawnień raportów Reporting Services przy pomocy skryptów PowerShell"><title>Konfiguracja Reporting Services przy pomocy PowerShell - arkadiusz wasniewski blog</title><link rel=canonical href=https://awasn.github.io/konfiguracja-reporting-services-przy-pomocy-powershell/><link rel=prev title="Implementacja Inversion of Control - wersja 1.1" href=https://awasn.github.io/implementacja-inversion-of-control-wersja-1-1/><link rel=next title="Zacznij od nowej strony" href=https://awasn.github.io/zacznij-od-nowej-strony/><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/pure-min.css integrity="sha256-Q0zCrUs2IfXWYx0uMKJfG93CvF6oVII21waYsAV4/8Q=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-min.css integrity="sha256-YqnnS/cQ7vE7gfVjdfx+JMi5EFD6m6Zqdemj81rs6PU=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/styles/agate.min.css><link rel=stylesheet href=https://awasn.github.io/awasn.min.f45a909800924faa836a73b82a1d4cb352f8053134a426a9dcafa61cf6a8c5d0.css integrity="sha256-9FqQmACST6qDanO4Kh1Ms1L4BTE0pCap3K+mHPaoxdA="></head><body><header><nav class=container><div class="pure-menu pure-menu-horizontal"><a class="pure-menu-heading pure-menu-link" href=https://awasn.github.io/>wasniewski</a><ul class="right pure-menu-list"><li class=pure-menu-item><a class=pure-menu-link href=https://awasn.github.io/blog/>blog</a></li><li class=pure-menu-item><a class=pure-menu-link href=https://awasn.github.io/categories/>categories</a></li><li class=pure-menu-item><a class=pure-menu-link href=https://awasn.github.io/tags/>tags</a></li><li class=pure-menu-item><a class=pure-menu-link href=https://awasn.github.io/about/>about</a></li></ul></div></nav></header><main class=container><aside class=post-published><p>This post was originally published on <a href=http://zine.net.pl/blogs/arkadiusz_wasniewski/archive/2009/02/20/konfiguracja-reporting-services-przy-pomocy-powershell.aspx target=_blank>zine.net.pl</a> on 20 February 2009 14:42 +0100</p></aside><article><header><h1>Konfiguracja Reporting Services przy pomocy PowerShell</h1><div class=post-metadata><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>20 February 2009 14:42 +0100
&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
11 min read</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-folder"><path d="M22 19a2 2 0 01-2 2H4a2 2 0 01-2-2V5a2 2 0 012-2h5l2 3h9a2 2 0 012 2z"/></svg><a href=https://awasn.github.io/categories/databases>Databases</a>
&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg>
<a href=https://awasn.github.io/tags/powershell>PowerShell</a>, <a href=https://awasn.github.io/tags/reporting-services>Reporting Services</a></div></div></header><p>Od pewnego czasu mam przyjemność budować od podstaw system raportowy w jednej z firm finansowych. Dzięki temu możliwe jest przejście przeze mnie całej ścieżki związanej z instalacją, konfiguracją serwera i uprawnień, tworzeniem raportów oraz ich zarządzaniem.</p><p>Pierwsze czynności są zawsze takie same. Trzeba pogrupować raporty według określonych przez właściciela biznesowego kategorii oraz nadać uprawnienia dostępu do poszczególnych raportów. Najłatwiej powiązać kategorie z działami występującymi w danej firmie oraz nałożyć uprawnienia dostępu na poziomie folderów. Oczywiście z biegiem czasu, kiedy raportów powstaje coraz więcej i rośnie świadomość użytkowników, zaczynają się pojawiać żądania dotyczące modyfikacji uprawnień, dostępu grup do folderów lub poszczególnych raportów. Przy dużej liczbie raportów i dużej liczbie tego typu żądań zarządzanie uprawnieniami zaczyna stawać się zadaniem, któremu może się okazać, iż poświęcamy zbyt wiele czasu.</p><h2 id=ograniczenia>Ograniczenia</h2><p>Załóżmy, iż na serwerze raportów mamy zdefiniowaną następującą strukturę folderów oraz zawartych w nich raportów:</p><figure><img class=pure-img src=https://awasn.github.io/konfiguracja-reporting-services-przy-pomocy-powershell/images/FolderyRaporty.png alt="Przykładowa struktura folderów i raportów"><figcaption><h4>Przykładowa struktura folderów i raportów</h4></figcaption></figure><p>Do folderu <strong>Folder_1</strong> dostęp ma grupa użytkowników <strong>Grupa_1</strong>, która jednocześnie nie ma dostępu do folderu <strong>Folder_2</strong>. W jaki sposób <strong>Grupa_1</strong> ma mieć zrealizowany dostęp do raportu <strong>Raport_2_3</strong>?</p><p>Pierwszy sposób do zrobienie skrótu (<strong>link</strong>) w <strong>Folder_1</strong> raportu <strong>Raport_2_3</strong>. Ale w zaprezentowanej strukturze <strong>Raport_2_3</strong> korzysta z podraportu <strong>Podraport_2_3_1</strong> oraz wywołuje raport <strong>Raport_2_2</strong>. To oznacza, iż podraport oraz odniesienie do raportu <strong>Raport_2_2</strong> w folderze <strong>Folder_1</strong> nie będą działać z powodu braku uprawnień. Czy zrobienie w związku z tym skrótu do <strong>Podraport_2_3_1</strong> i <strong>Raport_2_2</strong> w folderze <strong>Folder_1</strong> rozwiąże nam problem? Niestety nie. <strong>Raport_2_3</strong> dalej będzie się odwoływać do zawartości folderu <strong>Folder_2</strong>.</p><p>Jak inaczej można rozwiązać ten problem? Drugi sposób polega na wgraniu interesujących nas raportów całkowicie od nowa do właściwego folderu. Tylko, że takie podejście powoduje, iż przy dużej ilości takich zależności zarządzanie uaktualnianiem definicji raportu staje się pracochłonne i podatne na błędy – trzeba bowiem uaktualnić wszystkie wersje danego raportu w systemie.</p><p>Trzeci sposób wiąże się ze zmianą zarządzania uprawnieniami. Zamiast zarządzać dostępem na poziomie folderów należy przejść na poziom poszczególnych raportów. Problem w tym, iż uprawnienia folderu nadrzędnego to suma uprawnień wszystkich raportów i podfolderów. Jest to konieczne aby użytkownik mógł dostać się do folderu w celu przeglądania dostępnych raportów. Przez to łatwiejszym staje popełnienie błędu i udostępnienie dowolnego raportu wszystkim grupom, które mają dostęp do danego folderu.</p><p>Ze skrótami do raportów wiąże się jeszcze jeden ważny problem. Załóżmy, iż z jakiś względów do raportów w folderze <strong>Folder_2</strong> dostęp uzyskuje grupa <strong>Grupa_1</strong>. Uprawnienia są przyznawane na poziomie folderu. Następnie w folderze <strong>Folder_2</strong> tworzony jest skrót do raportu <strong>Raport_3_1</strong> z folderu <strong>Folder_3</strong>. Efektem tych zmian jest możliwość wywoływania raportu <strong>Raport_3_1</strong> przez grupę <strong>Grupa_1</strong> mimo, iż może wcale nie to było naszym celem.</p><h2 id=wybór-rozwiązania>Wybór rozwiązania</h2><p>Co w takim razie powinniśmy zrobić aby ogarnąć temat konfiguracji uprawnień? To co mnie się od razu nasunęło było skorzystanie ze skryptu. Nad wyborem języka skryptowego niewiele się zastanawiałem. Wybór PowerShell’a był w sumie dość oczywisty. Pozostało jedynie wybrać sposób komunikacji z usługami raportującymi. Pierwsza możliwość to skorzystanie z programu <strong>rs.exe</strong> dostępnego po instalacji Reporting Services. Aplikacja ta nie umożliwia jednak wykonywania bardziej zaawansowanych czynności przez co nie będziemy mogli z niej skorzystać. A sposób drugi?</p><p>Usługi raportujące składają się z dwóch aplikacji webowych:</p><ul><li><strong>ReportManager</strong>;</li><li><strong>ReportServer</strong>.</li></ul><p>Użytkownik końcowy najczęściej korzysta z <strong>ReportManager</strong> udostępnianej pod nazwą <strong>Reports</strong>. Aplikacja ta umożliwia między innymi przeglądanie i wyświetlanie raportów w ramach przeglądarki internetowej. <strong>ReportServer</strong> dostarcza natomiast usługi sieciowe wykorzystywane przez <strong>ReportManager</strong> w celu pobierania, wyświetlania i modyfikowania zawartości bazy danych serwera raportów.</p><p>Usługi sieciowe i PowerShell. Czemu nie…</p><h2 id=powershell-i-policy>PowerShell i Policy</h2><p>Kilka słów na temat zabezpieczeń PowerShell. Domyślnie po instalacji można uruchamiać jedynie skrypty podpisane. Poziom uprawnień można sprawdzić wpisując w konsoli PowerShell polecenie <code>Get-ExecutionPolicy</code>. Dozwolone wartości to:</p><ul><li><code>Restricted</code>;</li><li><code>AllSigned</code>;</li><li><code>RemoteSigned</code>;</li><li><code>Unrestricted</code>.</li></ul><p>Domyślne ograniczenie może być dla nas zbyt bolesne. Dlatego też jeśli mamy ustawiony poziom zabezpieczeń jako <code>Restricted</code> lub <code>AllSigned</code> możemy go zmienić na mniej restrykcyjny:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>Set-ExecutionPolicy RemoteSigned
</code></pre></div><p>Istnieje również możliwość skorzystania z <strong>Group Policy</strong> o czym można przeczytać na stronach <a href=http://www.windowsecurity.com/articles/PowerShell-Security.html>WindowSecurity.com</a>.</p><h2 id=parametry-startowe>Parametry startowe</h2><p>Rozpoczęcie wykonywania skryptu rozpoczynamy między innymi od zdefiniowania stałych:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>    <span style=color:#75715e># Adres serwera raportów</span>
    <span style=color:#66d9ef>[string]</span> $reportServerAddress = <span style=color:#e6db74>&#34;http://localhost/reportserver/reportservice2005.asmx?WSDL&#34;</span>

    <span style=color:#75715e># Miejsce składowania definicji raportów</span>
    <span style=color:#66d9ef>[string]</span> $reportProjectFolder = <span style=color:#e6db74>&#34;C:\Raporty\src&#34;</span>

    <span style=color:#75715e># Zmienne zawierające źródła danych wymaganych przez raporty</span>
    <span style=color:#66d9ef>[string]</span> $dataSourceReferenceName = <span style=color:#e6db74>&#34;/Data Sources/ReportsDataSource&#34;</span>

    <span style=color:#75715e># Miejsce nadrzędne dla konfigurowanych raportów. Katalog startowy</span>
    <span style=color:#66d9ef>[string]</span> $global:root = <span style=color:#e6db74>&#34;/&#34;</span>
</code></pre></div><p>oraz zmiennych globalnych:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>    $global:assembly = $null
    $global:proxy = $null
</code></pre></div><p>Adres serwera raportów zawsze będzie taki sam. Jedynie w przypadku konfiguracji zdalnej serwera raportów nazwę <strong>localhost</strong> należy zastąpić nazwą lub adresem właściwego komputera. Jeśli chodzi o źródła danych to zakładam, iż są one już utworzone w ramach usług raportujących. Dzięki temu unikam zapisywania w pliku konfigurującym ścieżek dostępu i haseł do serwerów baz danych. W powyższym przykładzie zdefiniowane jest tylko jedno źródło danych, ale w może być ich (tak jak u mnie w systemie produkcyjnym) oczywiście więcej. Zmienne <code>$global:assembly</code> oraz <code>$global:proxy</code> będą zawierać klasy umożliwiające zarządzanie serwerem raportów.</p><h2 id=przygotowanie-połączenia-z-serwerem-raportów>Przygotowanie połączenia z serwerem raportów</h2><p>Część rozwiązań, między innymi funkcja <code>New-WebServiceProxy</code> dostępna od PowerShell V2 (CTP3), zwraca obiekt proxy umożliwiający jedynie wykonywanie operacji udostępnianych przez usługi sieciowe serwera raportów. Jest to za mało, ponieważ potrzebować będziemy również możliwości tworzenia nowych obiektów. Dlatego też jako rozwiązanie właściwe wybrałem propozycję Christiana Glessnera. Szczegóły można znaleźć we wpisie <a href=http://cglessner.blogspot.com/2008/07/powershell-webservices-sharepoint.html>PowerShell, WebServices & SharePoint</a> na jego blogu. Źródła można pobrać z witryny <a href=http://www.codeplex.com/iLoveSharePoint/Release/ProjectReleases.aspx>http://www.codeplex.com/iLoveSharePoint/Release/ProjectReleases.aspx</a>.</p><p>W swoim rozwiązaniu wykorzystuję zmodyfikowaną wersję metody <code>Get-WebServiceProxy</code> ze skryptu Christiana Glessnera:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>    <span style=color:#66d9ef>function</span> Create-WebServiceProxy(
        <span style=color:#66d9ef>[string]</span> $url = $(<span style=color:#66d9ef>throw</span> <span style=color:#e6db74>&#39;Brak adresu serwera raportów!&#39;</span>))
    {
        Write-Host <span style=color:#e6db74>&#34;Nawiązywanie połączenia z serwerem $url&#34;</span>

        $fileName = <span style=color:#66d9ef>[System.IO.Path]</span>::Combine(
            <span style=color:#66d9ef>[System.Environment]</span>::CurrentDirectory,
            <span style=color:#e6db74>&#34;Proxy.ReportingServices2005&#34;</span>)
        <span style=color:#66d9ef>if</span>(!(Test-Path <span style=color:#e6db74>&#34;$fileName.dll&#34;</span>)){
            $WinSDK = <span style=color:#e6db74>&#34;$env:ProgramFiles\Microsoft SDKs\Windows\v6.0A\Bin&#34;</span>
            $Net35 = <span style=color:#e6db74>&#34;$env:SystemRoot\Microsoft.NET\Framework\v3.5&#34;</span>

            $null =&amp; $WinSdk\wsdl.exe $url /n:Proxy /out<span style=color:#960050;background-color:#1e0010>:</span><span style=color:#e6db74>&#34;$fileName.cs&#34;</span>
            $null =&amp; $Net35\csc.exe /t:library /out<span style=color:#960050;background-color:#1e0010>:</span><span style=color:#e6db74>&#34;$fileName.dll&#34;</span> <span style=color:#e6db74>&#34;$fileName.cs&#34;</span>
        }
        $global:assembly = <span style=color:#66d9ef>[System.Reflection.Assembly]</span>::LoadFrom(<span style=color:#e6db74>&#34;$fileName.dll&#34;</span>)
        $proxyType = $global:assembly.GetTypes() | Where-Object { $_.IsSubclassOf(
            <span style=color:#66d9ef>[System.Web.Services.Protocols.SoapHttpClientProtocol]</span>) <span style=color:#f92672>-eq</span> $true}
        $global:proxy = New-Object -TypeName $proxyType

        Write-Host <span style=color:#e6db74>&#34;Połączenie nawiązane&#34;</span>
    }
</code></pre></div><p>Jak widzimy, w powyższym kodzie tworzona, ładowana do pamięci i przechowywana w zmiennej globalnej <code>$global:assembly</code> jest biblioteka <strong>Proxy.ReportingServices2005.dll</strong> zawierająca wszystkie potrzebne typy. Zmienna globalna <code>$global:proxy</code> zawiera instancję klasy umożliwiającej odpytywanie usług sieciowych serwera raportowego znajdującego się w określonej przez nas lokalizacji.</p><p>Utworzenie biblioteki <strong>Proxy.ReportingServices2005.dll</strong> wymaga <strong>Microsoft SDKs</strong>, które wgrywane do systemu jest automatycznie w czasie instalacji Visual Studio. Jeśli z jakiś przyczyn na serwerze, na którym uruchamiamy powyższy skrypt nie ma i nie może być zainstalowane <strong>Microsoft SDKs</strong>, należy bibliotekę <strong>Proxy.ReportingServices2005.dll</strong> utworzyć na komputerze programisty, a następnie przekopiować razem ze skryptem w miejsce docelowe. Rozwiązanie zadziała. Dzięki warunkowi <code>if(!(Test-Path "$fileName.dll"))</code> biblioteka nie będzie ponownie tworzona jeśli już istnieje.</p><p>Czas na przygotowanie połączenia z serwerem raportów:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>    Create-WebServiceProxy $reportServerAddress
    $global:proxy.Credentials = <span style=color:#66d9ef>[System.Net.CredentialCache]</span>::DefaultCredentials
</code></pre></div><p>Koniecznie musimy pamiętać o przypisaniu danych uprawnionego użytkownika. W przypadku kiedy konfigurujemy <strong>localhost</strong> wystarczy przypisać aktualnie zalogowanego do komputera użytkownika – z definicji użytkownicy lokalni mają bowiem uprawnienia administracyjne w ramach usług raportowych.</p><h2 id=konfiguracja-folderu-startowego>Konfiguracja folderu startowego</h2><p>Po nawiązaniu połączenia z serwerem raportów czyścimy uprawnienia głównego katalogu, w ramach którego będziemy tworzyć foldery i wgrywać raporty.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>    $policies = Create-Policy $adminGroups <span style=color:#e6db74>&#34;WAW-RS\ReportUser&#34;</span>
    $global:proxy.SetPolicies(<span style=color:#e6db74>&#34;$root&#34;</span>, $policies)
</code></pre></div><p>Funkcja <code>Create-Policy</code> na podstawie przekazanych tablic zawierających łańcuchy z nazwami uprawnień tworzy odpowiednią kolekcję obiektów, którą możemy przekazać do usługi sieciowej <strong>SetPolicies</strong>. Zmienna <code>$adminGroups</code> zawiera minimalne uprawnienia administratora:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>    $adminGroups = <span style=color:#e6db74>&#34;BUILTIN\Administrators&#34;</span>
</code></pre></div><p>jeśli system, na którym uruchamiamy skrypt jest w angielskiej wersji językowej lub:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>    $adminGroups = <span style=color:#e6db74>&#34;BUILTIN\Administratorzy&#34;</span>
</code></pre></div><p>jeśli system jest w polskiej wersji językowej. W powyższym przykładzie do metody <code>Create-Policy</code> przekazujemy również uprawnienia do przeglądania raportów dla użytkownika <strong>&ldquo;WAW-RS\ReportUser&rdquo;</strong>. Serwer raportów może bowiem zawierać raporty dla innych aplikacji webowych, których nie będziemy konfigurować. Ważne jest, aby uprawnienia przekazywane do funkcji <code>Create-Policy</code> w skrypcie podawać zawsze z nazwą komputera!</p><p>Co natomiast robi funkcja <code>Create-Policy</code>? Oto jej kod:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>    <span style=color:#66d9ef>function</span> Create-Policy(<span style=color:#66d9ef>[string[]]</span> $adminGroups, <span style=color:#66d9ef>[string[]]</span> $browseGroups)
    {
        <span style=color:#66d9ef>[Proxy.Policy[]]</span> $policies = Create-AdminPolicy $adminGroups
        <span style=color:#66d9ef>foreach</span>($browseGroup <span style=color:#66d9ef>in</span> $browseGroups){
            $role = New-Object <span style=color:#e6db74>&#34;Proxy.Role&#34;</span>
            $role.Name = <span style=color:#e6db74>&#34;Browser&#34;</span>
            $policy = New-Object <span style=color:#e6db74>&#34;Proxy.Policy&#34;</span>
            $policy.GroupUserName = $browseGroup
            $policy.Roles += $role
            $policies += $policy
        }
        <span style=color:#66d9ef>return</span> $policies
    }
</code></pre></div><p>Oraz kod metody <code>Create-AdminPolicy</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>    <span style=color:#66d9ef>function</span> Create-AdminPolicy(<span style=color:#66d9ef>[string[]]</span> $adminGroups)
    {
        <span style=color:#66d9ef>[Proxy.Policy[]]</span> $policies = @()
        <span style=color:#66d9ef>foreach</span>($adminGroup <span style=color:#66d9ef>in</span> $adminGroups){
            $role = New-Object <span style=color:#e6db74>&#34;Proxy.Role&#34;</span>
            $role.Name = <span style=color:#e6db74>&#34;Content Manager&#34;</span>
            $policy = New-Object <span style=color:#e6db74>&#34;Proxy.Policy&#34;</span>
            $policy.GroupUserName = $adminGroup
            $policy.Roles += $role
            $policies += $policy
        }
        <span style=color:#66d9ef>return</span> $policies
    }
</code></pre></div><p>W funkcjach <code>Create-Policy</code> oraz <code>Create-AdminPolicy</code> dokonuję pewnych założeń i uproszczeń. Otóż każdej grupie przekazanej przez zmienną <code>$browseGroup</code> przypisywane jest uprawnienie <strong>&ldquo;Browser&rdquo;</strong>. Usługi raportujące mają więcej w tej materii możliwości, ale ponieważ nie korzystam z nich nie są przeze mnie w skrypcie obsługiwane.</p><h2 id=konfiguracja-folderów-i-raportów>Konfiguracja folderów i raportów</h2><p>Proces konfiguracji będzie przebiegał według następującego schematu:</p><ul><li>Utworzenie jeśli konieczne folderu dla raportów;</li><li>Nadanie niezbędnych uprawnień do folderu;</li><li>Wgranie jeśli konieczne pliku rdl z definicją raportu;</li><li>Konfiguracja właściwości raportu;</li><li>Przypisanie źródła danych do raportu;</li><li>Konfiguracja uprawnień dostępu do raportu;</li><li>Dodanie do folderów nadrzędnych uprawnień koniecznych do dostępu do raportu.</li></ul><p>Przykład załadowania i konfiguracji kilku kombinacji raportów:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>    Write-Host
    Write-Host <span style=color:#e6db74>&#34;Konfigurowanie raportów przykładowych&#34;</span>
    $folder = <span style=color:#e6db74>&#34;Raporty przykładowe&#34;</span>
    $reportPath = <span style=color:#e6db74>&#34;$reportProjectFolder\Raporty przykładowe&#34;</span>
    $browseGroups = <span style=color:#e6db74>&#34;AD\Grupa1&#34;</span>, <span style=color:#e6db74>&#34;AD\Grupa2&#34;</span>, <span style=color:#e6db74>&#34;AD\Grupa3&#34;</span>

    Create-Folder $folder $root $adminGroups
    $path = Combine-Path $root $folder

    Create-Report <span style=color:#e6db74>&#34;$path&#34;</span> <span style=color:#e6db74>&#34;$reportPath\Raport 1.rdl&#34;</span> $adminGroups
        $browseGroups $dataSourceReferenceName
    Create-Report <span style=color:#e6db74>&#34;$path&#34;</span> <span style=color:#e6db74>&#34;$reportPath\Raport 1 - podraport.rdl&#34;</span> $adminGroups
        $browseGroups $dataSourceReferenceName $hide
    Create-Report <span style=color:#e6db74>&#34;$path&#34;</span> <span style=color:#e6db74>&#34;$reportPath\Raport 2.rdl&#34;</span> $adminGroups
        ($browseGroups + <span style=color:#e6db74>&#34;AD\Grupa4&#34;</span>) $dataSourceReferenceName
    Create-Report <span style=color:#e6db74>&#34;$path&#34;</span> <span style=color:#e6db74>&#34;$reportPath\Raport 3.rdl&#34;</span> $adminGroups
        ($browseGroups + <span style=color:#e6db74>&#34;AD\Grupa4&#34;</span>, <span style=color:#e6db74>&#34;AD\Grupa5&#34;</span>) $dataSourceReferenceName
    Create-Report <span style=color:#e6db74>&#34;$path&#34;</span> <span style=color:#e6db74>&#34;$reportPath\Raport 4.rdl&#34;</span> $adminGroups
        $browseGroups $null
</code></pre></div><p>Stała pomocnicza <code>$hide</code> zwraca wartość <code>$true</code> i podawana jako parametr funkcji <code>Create-Report</code> umożliwia ukrycie raportu.</p><p>Po zdefiniowaniu wartości zmiennych zaczynamy od utworzenia i aktualizacji uprawnień folderu. Do tego wykorzystujemy metodę <code>Create-Folder</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>    <span style=color:#66d9ef>function</span> Create-Folder(<span style=color:#66d9ef>[string]</span> $folder, <span style=color:#66d9ef>[string]</span> $parent = <span style=color:#e6db74>&#34;/&#34;</span>, <span style=color:#66d9ef>[string[]]</span> $adminGroups)
    {
        <span style=color:#66d9ef>[string]</span> $path = Combine-Path $parent $folder
        <span style=color:#66d9ef>if</span>(!(ItemExists $parent $folder)){
            Write-Host <span style=color:#e6db74>&#34;Utworzenie folderu $path&#34;</span>
            $properties = @()
            $global:proxy.CreateFolder($folder, $parent, $properties)
        }
        Write-Host <span style=color:#e6db74>&#34;Usunięcie uprawnień dla folderu $path&#34;</span>
        $policies = Create-AdminPolicy $adminGroups
        $global:proxy.SetPolicies(<span style=color:#e6db74>&#34;$path&#34;</span>, $policies)
    }
</code></pre></div><p>Dwie metody pomocnicze wywoływane przez funkcję <code>Create-Folder</code> to:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>    <span style=color:#66d9ef>function</span> Combine-Path(<span style=color:#66d9ef>[string]</span> $path1, <span style=color:#66d9ef>[string]</span> $path2)
    {
        <span style=color:#66d9ef>[string]</span> $path = <span style=color:#66d9ef>[System.IO.Path]</span>::Combine($path1, $path2)
        <span style=color:#66d9ef>return</span> $path.Replace(<span style=color:#e6db74>&#34;\&#34;</span>, <span style=color:#e6db74>&#34;/&#34;</span>)
    }
</code></pre></div><p>umożliwiająca budowanie poprawnych ścieżek dostępu, oraz <code>ItemExists</code>, której zadaniem jest sprawdzenie czy w danej lokalizacji istnieje szukany przez nas element: folder, raport, źródło danych&mldr;</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>    <span style=color:#66d9ef>function</span> ItemExists(<span style=color:#66d9ef>[string]</span> $folder, <span style=color:#66d9ef>[string]</span> $name)
    {
        <span style=color:#66d9ef>[Proxy.BooleanOperatorEnum]</span> $operator = 0
        <span style=color:#66d9ef>[Proxy.ConditionEnum]</span> $condition = 1
        $searchCondition = New-Object <span style=color:#e6db74>&#34;Proxy.SearchCondition&#34;</span>
        $searchCondition.Condition = $condition
        $searchCondition.ConditionSpecified = $true
        $searchCondition.Name = <span style=color:#e6db74>&#34;Name&#34;</span>
        $searchCondition.Value = $name
        <span style=color:#66d9ef>[Proxy.CatalogItem[]]</span> $items =
            $global:proxy.FindItems($folder, $operator, $searchCondition)
        <span style=color:#66d9ef>return</span> $items <span style=color:#f92672>-and</span> ($items.Length <span style=color:#f92672>-cgt</span> 0)
    }
</code></pre></div><p>Największe jednak czynności są wykonywane w czasie wgrywania i konfigurowania konkretnego raportu:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>    <span style=color:#66d9ef>function</span> Create-Report(<span style=color:#66d9ef>[string]</span> $parent, <span style=color:#66d9ef>[string]</span> $path,
        <span style=color:#66d9ef>[string[]]</span> $adminGroups, <span style=color:#66d9ef>[string[]]</span> $browseGroups,
        <span style=color:#66d9ef>[string]</span> $dataSourceReferenceName,
        $hide = $false, $overwrite = $false)
    {
        Write-Host
        $name = <span style=color:#66d9ef>[System.IO.Path]</span>::GetFileNameWithoutExtension($path)
        $report = <span style=color:#e6db74>&#34;$parent/$name&#34;</span>

        <span style=color:#66d9ef>if</span>(!$overwrite){
            <span style=color:#66d9ef>if</span>(!(ItemExists $parent $name)){
                Upload-Report $parent $path $name $overwrite
            }
        }

        Set-ReportProperty $report $hide
        Set-ReportReferenceDataSource $report $dataSourceReferenceName
        <span style=color:#66d9ef>[Proxy.Policy[]]</span> $policies = Create-Policy $adminGroups $browseGroups
        Set-ReportPolicy $report $name $policies
        Set-FolderPolicy $parent $policies
    }
</code></pre></div><p>Domyślnie jeśli dany raport już istnieje to nie jest aktualizowana jego definicja. Poprzez modyfikację wartości domyślnej dla parametru <code>$overwrite</code> możemy zmienić zachowanie skryptu. Pamiętajmy, iż nie należy usuwać raportów w celu modyfikacji definicji aby nie stracić istniejących historii i subskrypcji. Domyślne zachowanie skryptu jest takie, aby można było go uruchamiać w dowolnym (no prawie) momencie w celu sprawdzenia i korekcji uprawnień.</p><p>Funkcja wgrywająca definicję raportu wygląda zaś następująco:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>    <span style=color:#66d9ef>function</span> Upload-Report(<span style=color:#66d9ef>[string]</span> $parent, <span style=color:#66d9ef>[string]</span> $path,
        <span style=color:#66d9ef>[string]</span> $name, <span style=color:#66d9ef>[bool]</span> $overwrite)
    {
        Write-Host <span style=color:#e6db74>&#34;Utworzenie raportu $report&#34;</span>
        $stream = <span style=color:#66d9ef>[System.IO.File]</span>::OpenRead($path)
        $definition = New-Object byte[] $stream.Length
        $stream.Read($definition, 0, $stream.Length)
        $stream.Close()
        $global:proxy.CreateReport($name, $parent,
            $overwrite, $definition, $null)
    }
</code></pre></div><p>Jak widzimy ułatwiamy sobie życie korzystając z bibliotek platformy .NET!</p><p>Właściwości, które ustawiamy są skromne.W chwili obecnej jest to jedynie ukrywanie raportu. Ma to sens na przykład w przypadku podraportów, które nie stanowią jednocześnie samodzielnego raportu:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>    <span style=color:#66d9ef>function</span> Set-ReportProperty(<span style=color:#66d9ef>[string]</span> $report, <span style=color:#66d9ef>[bool]</span> $hidden)
    {
        Write-Host <span style=color:#e6db74>&#34;Aktualizacja właściwości raportu $name&#34;</span>
        $property = New-Object <span style=color:#e6db74>&#34;Proxy.Property&#34;</span>
        $property.Name = <span style=color:#e6db74>&#34;Hidden&#34;</span>
        $property.Value = $hidden
        $properties = @($property)
        $global:proxy.SetProperties($report, $properties)
    }
</code></pre></div><p>Po ustawieniu właściwości następuje przypisanie źródła danych do raportu. Oczywiście nie każdy raport musi posiadać źródło danych. Stąd warunek na początku funkcji:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>    <span style=color:#66d9ef>function</span> Set-ReportReferenceDataSource(<span style=color:#66d9ef>[string]</span> $report,
        <span style=color:#66d9ef>[string]</span> $dataSourceReferenceName)
    {
        <span style=color:#66d9ef>if</span>($dataSourceReferenceName <span style=color:#f92672>-eq</span> $null <span style=color:#f92672>-or</span>
            $dataSourceReferenceName.Length <span style=color:#f92672>-lt</span> 1){
            <span style=color:#66d9ef>return</span>
        }

        Write-Host <span style=color:#e6db74>&#34;Aktualizacja źródła danych raportu $name&#34;</span>
        $dataSourceReference = New-Object <span style=color:#e6db74>&#34;Proxy.DataSourceReference&#34;</span>
        $dataSourceReference.Reference = $dataSourceReferenceName
        $dataSources = $global:proxy.GetItemDataSources($report)
        <span style=color:#75715e># Poniższe można odkomentować jeśli nie zależy nam na poprawności</span>
        <span style=color:#75715e># przypisań źródła danych</span>
        <span style=color:#75715e>#if($dataSources -eq $null){</span>
        <span style=color:#75715e>#    return</span>
        <span style=color:#75715e>#}</span>
        <span style=color:#66d9ef>foreach</span>($dataSource <span style=color:#66d9ef>in</span> $dataSources){
            $dataSource.Item = $dataSourceReference
        }
        $global:proxy.SetItemDataSources($report, $dataSources)
    }
</code></pre></div><p>W powyższym kodzie dokonuję kilku ważnych założeń. Po pierwsze jak już wcześniej mówiłem, zakładam, iż źródła danych w ramach usług raportowych są już utworzone. Dlatego też stosuję typ <code>Proxy.DataSourceReference</code>. Po drugie każdy raport korzysta docelowo tylko z jednego źródła danych. Nawet jeśli w czasie tworzenia raportu i jego testów wykorzystywałem dwa czy trzy źródła danych to na serwerze produkcyjnym mam tylko jedno źródło. Jeśli to założenie w Waszym przypadku nie będzie prawdziwe należy dokonać modyfikacji funkcji <code>Set-ReportReferenceDataSource</code> tak, aby parametr <code>$dataSourceReferenceName</code> był tablicą.</p><p>Przypisanie uprawnień do raportu:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>    <span style=color:#66d9ef>function</span> Set-ReportPolicy(<span style=color:#66d9ef>[string]</span> $report, <span style=color:#66d9ef>[string]</span> $name,
        <span style=color:#66d9ef>[Proxy.Policy[]]</span> $policies)
    {
        Write-Host <span style=color:#e6db74>&#34;Nadanie uprawnień do raportu $name&#34;</span>
        $global:proxy.SetPolicies($report, $policies)
    }
</code></pre></div><p>I na koniec rekurencyjne ustawienia właściwości folderu zawierającego konfigurowany raport. Znak <code>%</code> jest skrótowym zapisem polecenia <code>Foreach-Object</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>    <span style=color:#66d9ef>function</span> Set-FolderPolicy(<span style=color:#66d9ef>[string]</span> $parent, <span style=color:#66d9ef>[Proxy.Policy[]]</span> $policies)
    {
        $folderPolicies = @()
        $folderPoliciesInherited = <span style=color:#66d9ef>[ref]</span> $false
        $folderPolicies = $global:proxy.GetPolicies($parent,
            $folderPoliciesInherited)
        <span style=color:#66d9ef>foreach</span>($policy <span style=color:#66d9ef>in</span> $policies){
            <span style=color:#66d9ef>if</span>($($folderPolicies | % {$_.GroupUserName}) <span style=color:#f92672>-notcontains</span> $policy.GroupUserName){
                $folderPolicies += $policy
            }
        }
        Write-Host <span style=color:#e6db74>&#34;Aktualizacja uprawnień folderu $parent&#34;</span>
        $global:proxy.SetPolicies($parent, $folderPolicies)

        <span style=color:#66d9ef>if</span>($parent <span style=color:#f92672>-eq</span> $global:root){
            <span style=color:#66d9ef>return</span>
        }

        <span style=color:#66d9ef>for</span>($i = $parent.Length; 0, $i--){
            <span style=color:#66d9ef>if</span>($parent[$i] <span style=color:#f92672>-eq</span> <span style=color:#e6db74>&#34;/&#34;</span>){
                $newParent = $parent.Substring(0, $i)
                <span style=color:#66d9ef>if</span>($newParent.Length <span style=color:#f92672>-eq</span> 0){
                    $newParent = <span style=color:#e6db74>&#34;/&#34;</span>
                }
                Set-FolderPolicy $newParent $policies
                <span style=color:#66d9ef>break</span>
            }
        }
    }
</code></pre></div><p>Pamiętajmy o bardzo ważnym fakcie – uprawnienia folderu zawierający podfoldery i raporty są sumą uprawnień podfolderów i raportów!</p><h2 id=zakończenie>Zakończenie</h2><p>Uzbrojeni w taki skrypt możemy spokojnie wypłynąć na szerokie wody konfiguracyjne usług raportowych. Jedyne problemy jakie mogą nas spotkać dotyczyć będą sytuacji, kiedy będziemy próbowali skorzystać z protokołu https przy braku zaufanego certyfikatu. Nie ma bowiem możliwości potwierdzenia świadomego łączenia się z serwerem.</p><p>Osobom, które chciałyby spróbować swoich sił w wykorzystaniu języka PowerShell polecam pobranie darmowego <a href=http://www.powergui.org/>PowerGUI</a> umożliwiającego pisanie skryptów oraz zarządzanie (!) komputerem i nie tylko przy pomocy hierarchicznie zorganizowanych skryptów PowerShell. Warto również z sekcji <a href="http://www.powergui.org/kbcategory.jspa?categoryID=21">PowerPacks</a> pobrać pakiet <a href="http://www.powergui.org/entry.jspa?externalID=2045&categoryID=54">SQL Server 2005 Reporting Services Power Pack</a> umożliwiający zarządzanie usługami raportującymi.</p><p>Grafika (schemat folderów) została wykonana przy pomocy <a href=http://bubbl.us>http://bubbl.us</a>.</p></article><nav aria-label="Related posts"><h4>Related Posts</h4><ul><li><a href=https://awasn.github.io/reporting-services-projekty-po-polsku/>Reporting Services - projekt(y) po polsku?</a></li><li><a href=https://awasn.github.io/formsauthentication-w-reporing-services/>FormsAuthentication w Reporing Services</a></li></ul></nav><nav class="pure-g post-previous-next" aria-label="Previous and next posts"><div class="pure-u-11-24 previous"><a href=https://awasn.github.io/implementacja-inversion-of-control-wersja-1-1/ aria-label="Previous post"><span aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-left"><polyline points="15 18 9 12 15 6"/></svg></span></a><a href=https://awasn.github.io/implementacja-inversion-of-control-wersja-1-1/>Implementacja Inversion of Control - wersja 1.1</a></div><div class=pure-u-2-24>&nbsp;</div><div class="pure-u-11-24 next"><a href=https://awasn.github.io/zacznij-od-nowej-strony/>Zacznij od nowej strony</a>
<a href=https://awasn.github.io/zacznij-od-nowej-strony/ aria-label="Next post"><span aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"><polyline points="9 18 15 12 9 6"/></svg></span></a></div></nav></main><footer><div class="center-aligned container"><p>Copyright &copy; 2007-2021 Arkadiusz Waśniewski. All Rights Reserved.</p></div></footer><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/languages/accesslog.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/languages/dockerfile.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/languages/dos.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/languages/powershell.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/languages/routeros.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/languages/yaml.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/languages/vbnet.min.js></script><script>hljs.initHighlightingOnLoad()</script></body></html>