<!DOCTYPE HTML>
<html lang="pl-pl">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="generator" content="Hugo 0.54.0" />
        <meta name="description" content="Konfiguracja struktury i uprawnień raportów Reporting Services przy pomocy skryptów PowerShell" />
        <title>Konfiguracja Reporting Services przy pomocy PowerShell - arkadiusz wasniewski blog</title>
        <link rel="canonical" href="https://awasn.github.io/konfiguracja-reporting-services-przy-pomocy-powershell/">
        <link rel="prev" title="Implementacja Inversion of Control - wersja 1.1" href="https://awasn.github.io/implementacja-inversion-of-control-wersja-1-1/">
        <link rel="next" title="Zacznij od nowej strony" href="https://awasn.github.io/zacznij-od-nowej-strony/">

        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/pure-min.css" integrity="sha256-Q0zCrUs2IfXWYx0uMKJfG93CvF6oVII21waYsAV4/8Q=" crossorigin="anonymous" />
        
        
            <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-min.css" integrity="sha256-YqnnS/cQ7vE7gfVjdfx+JMi5EFD6m6Zqdemj81rs6PU=" crossorigin="anonymous" />
        
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/styles/agate.min.css">
        <link rel="stylesheet" href="https://awasn.github.io/awasn.min.f635c2298033f6f9947349ea417d9e9d94017493351f739bf1b756d5b5bccf61.css" integrity="sha256-9jXCKYAz9vmUc0nqQX2enZQBdJM1H3Ob8bdW1bW8z2E=" />

    </head>
    <body>
        <header>
            <nav class="container" >
                <div class="pure-menu pure-menu-horizontal">
                    <a class="pure-menu-heading pure-menu-link" href="https://awasn.github.io/">wasniewski</a>
                    <ul class="right pure-menu-list">
                        <li class="pure-menu-item"><a class="pure-menu-link" href="https://awasn.github.io/blog/">blog</a></li>
                        <li class="pure-menu-item"><a class="pure-menu-link" href="https://awasn.github.io/categories/">categories</a></li>
                        <li class="pure-menu-item"><a class="pure-menu-link" href="https://awasn.github.io/tags/">tags</a></li>
                        <li class="pure-menu-item"><a class="pure-menu-link" href="https://awasn.github.io/about/">about</a></li>
                    </ul>
                </div>
            </nav>
        </header>

        <main class="container">
            
    <aside class="post-published">
        <p>This post was originally published on <a href="http://zine.net.pl/blogs/arkadiusz_wasniewski/archive/2009/02/20/konfiguracja-reporting-services-przy-pomocy-powershell.aspx" target="_blank">zine.net.pl</a> on 20 February 2009 14:42 CET</p>
    </aside>

    <article>
        <header>
            <h1>Konfiguracja Reporting Services przy pomocy PowerShell</h1>
                <div class="post-metadata">
        <div>
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>
            20 February 2009 14:42 CET
            
            &nbsp;
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>
            11 min read
        </div>
        <div>
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-folder"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg>
            <a href="https://awasn.github.io/categories/databases">Databases</a>
            
                &nbsp;
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg>
                <a href="https://awasn.github.io/tags/powershell">PowerShell</a>, <a href="https://awasn.github.io/tags/reporting-services">Reporting Services</a>
            
        </div>
    </div>
        </header>

        

<p>Od pewnego czasu mam przyjemność budować od podstaw system raportowy w jednej z firm finansowych. Dzięki temu możliwe jest przejście przeze mnie całej ścieżki związanej z instalacją, konfiguracją serwera i uprawnień, tworzeniem raportów oraz ich zarządzaniem.</p>

<p>Pierwsze czynności są zawsze takie same. Trzeba pogrupować raporty według określonych przez właściciela biznesowego kategorii oraz nadać uprawnienia dostępu do poszczególnych raportów. Najłatwiej powiązać kategorie z działami występującymi w danej firmie oraz nałożyć uprawnienia dostępu na poziomie folderów. Oczywiście z biegiem czasu, kiedy raportów powstaje coraz więcej i rośnie świadomość użytkowników, zaczynają się pojawiać żądania dotyczące modyfikacji uprawnień, dostępu grup do folderów lub poszczególnych raportów. Przy dużej liczbie raportów i dużej liczbie tego typu żądań zarządzanie uprawnieniami zaczyna stawać się zadaniem, któremu może się okazać, iż poświęcamy zbyt wiele czasu.</p>

<h2 id="ograniczenia">Ograniczenia</h2>

<p>Załóżmy, iż na serwerze raportów mamy zdefiniowaną następującą strukturę folderów oraz zawartych w nich raportów:</p>

    <figure itemprop="image" itemscope itemtype="http://schema.org/ImageObject">
        <img src="https://awasn.github.io/konfiguracja-reporting-services-przy-pomocy-powershell/images/FolderyRaporty.png" alt="Przykładowa struktura folderów i raportów" itemprop="contentUrl">
        <figcaption itemprop="caption"><h4>Przykładowa struktura folderów i raportów</h4></figcaption>
    </figure>

<p>Do folderu <strong>Folder_1</strong> dostęp ma grupa użytkowników <strong>Grupa_1</strong>, która jednocześnie nie ma dostępu do folderu <strong>Folder_2</strong>. W jaki sposób <strong>Grupa_1</strong> ma mieć zrealizowany dostęp do raportu <strong>Raport_2_3</strong>?</p>

<p>Pierwszy sposób do zrobienie skrótu (<strong>link</strong>) w <strong>Folder_1</strong> raportu <strong>Raport_2_3</strong>. Ale w zaprezentowanej strukturze <strong>Raport_2_3</strong> korzysta z podraportu <strong>Podraport_2_3_1</strong> oraz wywołuje raport <strong>Raport_2_2</strong>. To oznacza, iż podraport oraz odniesienie do raportu <strong>Raport_2_2</strong> w folderze <strong>Folder_1</strong> nie będą działać z powodu braku uprawnień. Czy zrobienie w związku z tym skrótu do <strong>Podraport_2_3_1</strong> i <strong>Raport_2_2</strong> w folderze <strong>Folder_1</strong> rozwiąże nam problem? Niestety nie. <strong>Raport_2_3</strong> dalej będzie się odwoływać do zawartości folderu <strong>Folder_2</strong>.</p>

<p>Jak inaczej można rozwiązać ten problem? Drugi sposób polega na wgraniu interesujących nas raportów całkowicie od nowa do właściwego folderu. Tylko, że takie podejście powoduje, iż przy dużej ilości takich zależności zarządzanie uaktualnianiem definicji raportu staje się pracochłonne i podatne na błędy – trzeba bowiem uaktualnić wszystkie wersje danego raportu w systemie.</p>

<p>Trzeci sposób wiąże się ze zmianą zarządzania uprawnieniami. Zamiast zarządzać dostępem na poziomie folderów należy przejść na poziom poszczególnych raportów. Problem w tym, iż uprawnienia folderu nadrzędnego to suma uprawnień wszystkich raportów i podfolderów. Jest to konieczne aby użytkownik mógł dostać się do folderu w celu przeglądania dostępnych raportów. Przez to łatwiejszym staje popełnienie błędu i udostępnienie dowolnego raportu wszystkim grupom, które mają dostęp do danego folderu.</p>

<p>Ze skrótami do raportów wiąże się jeszcze jeden ważny problem. Załóżmy, iż z jakiś względów do raportów w folderze <strong>Folder_2</strong> dostęp uzyskuje grupa <strong>Grupa_1</strong>. Uprawnienia są przyznawane na poziomie folderu. Następnie w folderze <strong>Folder_2</strong> tworzony jest skrót do raportu <strong>Raport_3_1</strong> z folderu <strong>Folder_3</strong>. Efektem tych zmian jest możliwość wywoływania raportu <strong>Raport_3_1</strong> przez grupę <strong>Grupa_1</strong> mimo, iż może wcale nie to było naszym celem.</p>

<h2 id="wybór-rozwiązania">Wybór rozwiązania</h2>

<p>Co w takim razie powinniśmy zrobić aby ogarnąć temat konfiguracji uprawnień? To co mnie się od razu nasunęło było skorzystanie ze skryptu. Nad wyborem języka skryptowego niewiele się zastanawiałem. Wybór PowerShell’a był w sumie dość oczywisty. Pozostało jedynie wybrać sposób komunikacji z  usługami raportującymi. Pierwsza możliwość to skorzystanie z programu <strong>rs.exe</strong> dostępnego po instalacji Reporting Services. Aplikacja ta nie umożliwia jednak wykonywania bardziej zaawansowanych czynności przez co nie będziemy mogli z niej skorzystać. A sposób drugi?</p>

<p>Usługi raportujące składają się z dwóch aplikacji webowych:</p>

<ul>
<li><strong>ReportManager</strong>;</li>
<li><strong>ReportServer</strong>.</li>
</ul>

<p>Użytkownik końcowy najczęściej korzysta z <strong>ReportManager</strong> udostępnianej pod nazwą <strong>Reports</strong>. Aplikacja ta umożliwia między innymi przeglądanie i wyświetlanie raportów w ramach przeglądarki internetowej. <strong>ReportServer</strong> dostarcza natomiast usługi sieciowe wykorzystywane przez <strong>ReportManager</strong> w celu pobierania, wyświetlania i modyfikowania zawartości bazy danych serwera raportów.</p>

<p>Usługi sieciowe i PowerShell. Czemu nie…</p>

<h2 id="powershell-i-policy">PowerShell i Policy</h2>

<p>Kilka słów na temat zabezpieczeń PowerShell. Domyślnie po instalacji można uruchamiać jedynie skrypty podpisane. Poziom uprawnień można sprawdzić wpisując w konsoli PowerShell polecenie <code>Get-ExecutionPolicy</code>. Dozwolone wartości to:</p>

<ul>
<li><code>Restricted</code>;</li>
<li><code>AllSigned</code>;</li>
<li><code>RemoteSigned</code>;</li>
<li><code>Unrestricted</code>.</li>
</ul>

<p>Domyślne ograniczenie może być dla nas zbyt bolesne. Dlatego też jeśli mamy ustawiony poziom zabezpieczeń jako <code>Restricted</code> lub <code>AllSigned</code> możemy go zmienić na mniej restrykcyjny:</p>

<pre><code class="language-powershell">Set-ExecutionPolicy RemoteSigned
</code></pre>

<p>Istnieje również możliwość skorzystania z <strong>Group Policy</strong> o czym można przeczytać na stronach <a href="http://www.windowsecurity.com/articles/PowerShell-Security.html" target="_blank">WindowSecurity.com</a>.</p>

<h2 id="parametry-startowe">Parametry startowe</h2>

<p>Rozpoczęcie wykonywania skryptu rozpoczynamy między innymi od zdefiniowania stałych:</p>

<pre><code class="language-powershell">    # Adres serwera raportów
    [string] $reportServerAddress = &quot;http://localhost/reportserver/reportservice2005.asmx?WSDL&quot;

    # Miejsce składowania definicji raportów
    [string] $reportProjectFolder = &quot;C:\Raporty\src&quot;

    # Zmienne zawierające źródła danych wymaganych przez raporty
    [string] $dataSourceReferenceName = &quot;/Data Sources/ReportsDataSource&quot;

    # Miejsce nadrzędne dla konfigurowanych raportów. Katalog startowy
    [string] $global:root = &quot;/&quot;
</code></pre>

<p>oraz zmiennych globalnych:</p>

<pre><code class="language-powershell">    $global:assembly = $null
    $global:proxy = $null
</code></pre>

<p>Adres serwera raportów zawsze będzie taki sam. Jedynie w przypadku konfiguracji zdalnej serwera raportów nazwę <strong>localhost</strong> należy zastąpić nazwą lub adresem właściwego komputera. Jeśli chodzi o źródła danych to zakładam, iż są one już utworzone w ramach usług raportujących. Dzięki temu unikam zapisywania w pliku konfigurującym ścieżek dostępu i haseł do serwerów baz danych. W powyższym przykładzie zdefiniowane jest tylko jedno źródło danych, ale w może być ich (tak jak u mnie w systemie produkcyjnym) oczywiście więcej. Zmienne <code>$global:assembly</code> oraz <code>$global:proxy</code> będą zawierać klasy umożliwiające zarządzanie serwerem raportów.</p>

<h2 id="przygotowanie-połączenia-z-serwerem-raportów">Przygotowanie połączenia z serwerem raportów</h2>

<p>Część rozwiązań, między innymi funkcja <code>New-WebServiceProxy</code> dostępna od PowerShell V2 (CTP3), zwraca obiekt proxy umożliwiający jedynie wykonywanie operacji udostępnianych przez usługi sieciowe serwera raportów. Jest to za mało, ponieważ potrzebować będziemy również możliwości tworzenia nowych obiektów. Dlatego też jako rozwiązanie właściwe wybrałem propozycję Christiana Glessnera. Szczegóły można znaleźć we wpisie <a href="http://cglessner.blogspot.com/2008/07/powershell-webservices-sharepoint.html" target="_blank">PowerShell, WebServices &amp; SharePoint</a> na jego blogu. Źródła można pobrać z witryny <a href="http://www.codeplex.com/iLoveSharePoint/Release/ProjectReleases.aspx" target="_blank">http://www.codeplex.com/iLoveSharePoint/Release/ProjectReleases.aspx</a>.</p>

<p>W swoim rozwiązaniu wykorzystuję zmodyfikowaną wersję metody <code>Get-WebServiceProxy</code> ze skryptu Christiana Glessnera:</p>

<pre><code class="language-powershell">    function Create-WebServiceProxy(
        [string] $url = $(throw 'Brak adresu serwera raportów!'))
    {
        Write-Host &quot;Nawiązywanie połączenia z serwerem $url&quot;

        $fileName = [System.IO.Path]::Combine(
            [System.Environment]::CurrentDirectory,
            &quot;Proxy.ReportingServices2005&quot;)
        if(!(Test-Path &quot;$fileName.dll&quot;)){
            $WinSDK = &quot;$env:ProgramFiles\Microsoft SDKs\Windows\v6.0A\Bin&quot;
            $Net35 = &quot;$env:SystemRoot\Microsoft.NET\Framework\v3.5&quot;

            $null =&amp; $WinSdk\wsdl.exe $url /n:Proxy /out:&quot;$fileName.cs&quot;
            $null =&amp; $Net35\csc.exe /t:library /out:&quot;$fileName.dll&quot; &quot;$fileName.cs&quot;
        }
        $global:assembly = [System.Reflection.Assembly]::LoadFrom(&quot;$fileName.dll&quot;)
        $proxyType = $global:assembly.GetTypes() | Where-Object { $_.IsSubclassOf(
            [System.Web.Services.Protocols.SoapHttpClientProtocol]) -eq $true}
        $global:proxy = New-Object -TypeName $proxyType

        Write-Host &quot;Połączenie nawiązane&quot;
    }
</code></pre>

<p>Jak widzimy, w powyższym kodzie tworzona, ładowana do pamięci i przechowywana w zmiennej globalnej <code>$global:assembly</code> jest biblioteka <strong>Proxy.ReportingServices2005.dll</strong> zawierająca wszystkie potrzebne typy. Zmienna globalna <code>$global:proxy</code> zawiera instancję klasy umożliwiającej odpytywanie usług sieciowych serwera raportowego znajdującego się w określonej przez nas lokalizacji.</p>

<p>Utworzenie biblioteki <strong>Proxy.ReportingServices2005.dll</strong> wymaga <strong>Microsoft SDKs</strong>, które wgrywane do systemu jest automatycznie w czasie instalacji Visual Studio. Jeśli z jakiś przyczyn na serwerze, na którym uruchamiamy powyższy skrypt nie ma i nie może być zainstalowane <strong>Microsoft SDKs</strong>, należy bibliotekę <strong>Proxy.ReportingServices2005.dll</strong> utworzyć na komputerze programisty, a następnie przekopiować razem ze skryptem w miejsce docelowe. Rozwiązanie zadziała. Dzięki warunkowi <code>if(!(Test-Path &quot;$fileName.dll&quot;))</code> biblioteka nie będzie ponownie tworzona jeśli już istnieje.</p>

<p>Czas na przygotowanie połączenia z serwerem raportów:</p>

<pre><code class="language-powershell">    Create-WebServiceProxy $reportServerAddress
    $global:proxy.Credentials = [System.Net.CredentialCache]::DefaultCredentials
</code></pre>

<p>Koniecznie musimy pamiętać o przypisaniu danych uprawnionego użytkownika. W przypadku kiedy konfigurujemy <strong>localhost</strong> wystarczy przypisać aktualnie zalogowanego do komputera użytkownika – z definicji użytkownicy lokalni mają bowiem uprawnienia administracyjne w ramach usług raportowych.</p>

<h2 id="konfiguracja-folderu-startowego">Konfiguracja folderu startowego</h2>

<p>Po nawiązaniu połączenia z serwerem raportów czyścimy uprawnienia głównego katalogu, w ramach którego będziemy tworzyć foldery i wgrywać raporty.</p>

<pre><code class="language-powershell">    $policies = Create-Policy $adminGroups &quot;WAW-RS\ReportUser&quot;
    $global:proxy.SetPolicies(&quot;$root&quot;, $policies)
</code></pre>

<p>Funkcja <code>Create-Policy</code> na podstawie przekazanych tablic zawierających łańcuchy z nazwami uprawnień tworzy odpowiednią kolekcję obiektów, którą możemy przekazać do usługi sieciowej <strong>SetPolicies</strong>. Zmienna <code>$adminGroups</code> zawiera minimalne uprawnienia administratora:</p>

<pre><code class="language-powershell">    $adminGroups = &quot;BUILTIN\Administrators&quot;
</code></pre>

<p>jeśli system, na którym uruchamiamy skrypt jest w angielskiej wersji językowej lub:</p>

<pre><code class="language-powershell">    $adminGroups = &quot;BUILTIN\Administratorzy&quot;
</code></pre>

<p>jeśli system jest w polskiej wersji językowej. W powyższym przykładzie do metody <code>Create-Policy</code> przekazujemy również uprawnienia do przeglądania raportów dla użytkownika <strong>&ldquo;WAW-RS\ReportUser&rdquo;</strong>. Serwer raportów może bowiem zawierać raporty dla innych aplikacji webowych, których nie będziemy konfigurować. Ważne jest, aby uprawnienia przekazywane do funkcji <code>Create-Policy</code> w skrypcie podawać zawsze z nazwą komputera!</p>

<p>Co natomiast robi funkcja <code>Create-Policy</code>? Oto jej kod:</p>

<pre><code class="language-powershell">    function Create-Policy([string[]] $adminGroups, [string[]] $browseGroups)
    {
        [Proxy.Policy[]] $policies = Create-AdminPolicy $adminGroups
        foreach($browseGroup in $browseGroups){
            $role = New-Object &quot;Proxy.Role&quot;
            $role.Name = &quot;Browser&quot;
            $policy = New-Object &quot;Proxy.Policy&quot;
            $policy.GroupUserName = $browseGroup
            $policy.Roles += $role
            $policies += $policy
        }
        return $policies
    }
</code></pre>

<p>Oraz kod metody <code>Create-AdminPolicy</code>:</p>

<pre><code class="language-powershell">    function Create-AdminPolicy([string[]] $adminGroups)
    {
        [Proxy.Policy[]] $policies = @()
        foreach($adminGroup in $adminGroups){
            $role = New-Object &quot;Proxy.Role&quot;
            $role.Name = &quot;Content Manager&quot;
            $policy = New-Object &quot;Proxy.Policy&quot;
            $policy.GroupUserName = $adminGroup
            $policy.Roles += $role
            $policies += $policy
        }
        return $policies
    }
</code></pre>

<p>W funkcjach <code>Create-Policy</code> oraz <code>Create-AdminPolicy</code> dokonuję pewnych założeń i uproszczeń. Otóż każdej grupie przekazanej przez zmienną <code>$browseGroup</code> przypisywane jest uprawnienie <strong>&ldquo;Browser&rdquo;</strong>. Usługi raportujące mają więcej w tej materii możliwości, ale ponieważ nie korzystam z nich nie są przeze mnie w  skrypcie obsługiwane.</p>

<h2 id="konfiguracja-folderów-i-raportów">Konfiguracja folderów i raportów</h2>

<p>Proces konfiguracji będzie przebiegał według następującego schematu:</p>

<ul>
<li>Utworzenie jeśli konieczne folderu dla raportów;</li>
<li>Nadanie niezbędnych uprawnień do folderu;</li>
<li>Wgranie jeśli konieczne pliku rdl z definicją raportu;</li>
<li>Konfiguracja właściwości raportu;</li>
<li>Przypisanie źródła danych do raportu;</li>
<li>Konfiguracja uprawnień dostępu do raportu;</li>
<li>Dodanie do folderów nadrzędnych uprawnień koniecznych do dostępu do raportu.</li>
</ul>

<p>Przykład załadowania i konfiguracji kilku kombinacji raportów:</p>

<pre><code class="language-powershell">    Write-Host
    Write-Host &quot;Konfigurowanie raportów przykładowych&quot;
    $folder = &quot;Raporty przykładowe&quot;
    $reportPath = &quot;$reportProjectFolder\Raporty przykładowe&quot;
    $browseGroups = &quot;AD\Grupa1&quot;, &quot;AD\Grupa2&quot;, &quot;AD\Grupa3&quot;

    Create-Folder $folder $root $adminGroups
    $path = Combine-Path $root $folder

    Create-Report &quot;$path&quot; &quot;$reportPath\Raport 1.rdl&quot; $adminGroups
        $browseGroups $dataSourceReferenceName
    Create-Report &quot;$path&quot; &quot;$reportPath\Raport 1 - podraport.rdl&quot; $adminGroups
        $browseGroups $dataSourceReferenceName $hide
    Create-Report &quot;$path&quot; &quot;$reportPath\Raport 2.rdl&quot; $adminGroups
        ($browseGroups + &quot;AD\Grupa4&quot;) $dataSourceReferenceName
    Create-Report &quot;$path&quot; &quot;$reportPath\Raport 3.rdl&quot; $adminGroups
        ($browseGroups + &quot;AD\Grupa4&quot;, &quot;AD\Grupa5&quot;) $dataSourceReferenceName
    Create-Report &quot;$path&quot; &quot;$reportPath\Raport 4.rdl&quot; $adminGroups
        $browseGroups $null
</code></pre>

<p>Stała pomocnicza <code>$hide</code> zwraca wartość <code>$true</code> i podawana jako parametr funkcji <code>Create-Report</code> umożliwia ukrycie raportu.</p>

<p>Po zdefiniowaniu wartości zmiennych zaczynamy od utworzenia i aktualizacji uprawnień folderu. Do tego wykorzystujemy metodę <code>Create-Folder</code>:</p>

<pre><code class="language-powershell">    function Create-Folder([string] $folder, [string] $parent = &quot;/&quot;, [string[]] $adminGroups)
    {
        [string] $path = Combine-Path $parent $folder
        if(!(ItemExists $parent $folder)){
            Write-Host &quot;Utworzenie folderu $path&quot;
            $properties = @()
            $global:proxy.CreateFolder($folder, $parent, $properties)
        }
        Write-Host &quot;Usunięcie uprawnień dla folderu $path&quot;
        $policies = Create-AdminPolicy $adminGroups
        $global:proxy.SetPolicies(&quot;$path&quot;, $policies)
    }
</code></pre>

<p>Dwie metody pomocnicze wywoływane przez funkcję <code>Create-Folder</code> to:</p>

<pre><code class="language-powershell">    function Combine-Path([string] $path1, [string] $path2)
    {
        [string] $path = [System.IO.Path]::Combine($path1, $path2)
        return $path.Replace(&quot;\&quot;, &quot;/&quot;)
    }
</code></pre>

<p>umożliwiająca budowanie poprawnych ścieżek dostępu, oraz <code>ItemExists</code>, której zadaniem jest sprawdzenie czy w danej lokalizacji istnieje szukany przez nas element: folder, raport, źródło danych&hellip;</p>

<pre><code class="language-powershell">    function ItemExists([string] $folder, [string] $name)
    {
        [Proxy.BooleanOperatorEnum] $operator = 0
        [Proxy.ConditionEnum] $condition = 1
        $searchCondition = New-Object &quot;Proxy.SearchCondition&quot;
        $searchCondition.Condition = $condition
        $searchCondition.ConditionSpecified = $true
        $searchCondition.Name = &quot;Name&quot;
        $searchCondition.Value = $name
        [Proxy.CatalogItem[]] $items =
            $global:proxy.FindItems($folder, $operator, $searchCondition)
        return $items -and ($items.Length -cgt 0)
    }
</code></pre>

<p>Największe jednak czynności są wykonywane w czasie wgrywania i konfigurowania konkretnego raportu:</p>

<pre><code class="language-powershell">    function Create-Report([string] $parent, [string] $path,
        [string[]] $adminGroups, [string[]] $browseGroups,
        [string] $dataSourceReferenceName,
        $hide = $false, $overwrite = $false)
    {
        Write-Host
        $name = [System.IO.Path]::GetFileNameWithoutExtension($path)
        $report = &quot;$parent/$name&quot;

        if(!$overwrite){
            if(!(ItemExists $parent $name)){
                Upload-Report $parent $path $name $overwrite
            }
        }

        Set-ReportProperty $report $hide
        Set-ReportReferenceDataSource $report $dataSourceReferenceName
        [Proxy.Policy[]] $policies = Create-Policy $adminGroups $browseGroups
        Set-ReportPolicy $report $name $policies
        Set-FolderPolicy $parent $policies
    }
</code></pre>

<p>Domyślnie jeśli dany raport już istnieje to nie jest aktualizowana jego definicja. Poprzez modyfikację wartości domyślnej dla parametru <code>$overwrite</code> możemy zmienić zachowanie skryptu. Pamiętajmy, iż nie należy usuwać raportów w celu modyfikacji definicji aby nie stracić istniejących historii i subskrypcji. Domyślne zachowanie skryptu jest takie, aby można było go uruchamiać w dowolnym (no prawie) momencie w celu sprawdzenia i korekcji uprawnień.</p>

<p>Funkcja wgrywająca definicję raportu wygląda zaś następująco:</p>

<pre><code class="language-powershell">    function Upload-Report([string] $parent, [string] $path,
        [string] $name, [bool] $overwrite)
    {
        Write-Host &quot;Utworzenie raportu $report&quot;
        $stream = [System.IO.File]::OpenRead($path)
        $definition = New-Object byte[] $stream.Length
        $stream.Read($definition, 0, $stream.Length)
        $stream.Close()
        $global:proxy.CreateReport($name, $parent,
            $overwrite, $definition, $null)
    }
</code></pre>

<p>Jak widzimy ułatwiamy sobie życie korzystając z bibliotek platformy .NET!</p>

<p>Właściwości, które ustawiamy są skromne.W chwili obecnej jest to jedynie ukrywanie raportu. Ma to sens na przykład w przypadku podraportów, które nie stanowią jednocześnie samodzielnego raportu:</p>

<pre><code class="language-powershell">    function Set-ReportProperty([string] $report, [bool] $hidden)
    {
        Write-Host &quot;Aktualizacja właściwości raportu $name&quot;
        $property = New-Object &quot;Proxy.Property&quot;
        $property.Name = &quot;Hidden&quot;
        $property.Value = $hidden
        $properties = @($property)
        $global:proxy.SetProperties($report, $properties)
    }
</code></pre>

<p>Po ustawieniu właściwości następuje przypisanie źródła danych do raportu. Oczywiście nie każdy raport musi posiadać źródło danych. Stąd warunek na początku funkcji:</p>

<pre><code class="language-powershell">    function Set-ReportReferenceDataSource([string] $report,
        [string] $dataSourceReferenceName)
    {
        if($dataSourceReferenceName -eq $null -or
            $dataSourceReferenceName.Length -lt 1){
            return
        }

        Write-Host &quot;Aktualizacja źródła danych raportu $name&quot;
        $dataSourceReference = New-Object &quot;Proxy.DataSourceReference&quot;
        $dataSourceReference.Reference = $dataSourceReferenceName
        $dataSources = $global:proxy.GetItemDataSources($report)
        # Poniższe można odkomentować jeśli nie zależy nam na poprawności
        # przypisań źródła danych
        #if($dataSources -eq $null){
        #    return
        #}
        foreach($dataSource in $dataSources){
            $dataSource.Item = $dataSourceReference
        }
        $global:proxy.SetItemDataSources($report, $dataSources)
    }
</code></pre>

<p>W powyższym kodzie dokonuję kilku ważnych założeń. Po pierwsze jak już wcześniej mówiłem, zakładam, iż źródła danych w ramach usług raportowych są już utworzone. Dlatego też stosuję typ <code>Proxy.DataSourceReference</code>. Po drugie każdy raport korzysta docelowo tylko z jednego źródła danych. Nawet jeśli w czasie tworzenia raportu i jego testów wykorzystywałem dwa czy trzy źródła danych to na serwerze produkcyjnym mam tylko jedno źródło. Jeśli to założenie w Waszym przypadku nie będzie prawdziwe należy dokonać modyfikacji funkcji <code>Set-ReportReferenceDataSource</code> tak, aby parametr <code>$dataSourceReferenceName</code> był tablicą.</p>

<p>Przypisanie uprawnień do raportu:</p>

<pre><code class="language-powershell">    function Set-ReportPolicy([string] $report, [string] $name,
        [Proxy.Policy[]] $policies)
    {
        Write-Host &quot;Nadanie uprawnień do raportu $name&quot;
        $global:proxy.SetPolicies($report, $policies)
    }
</code></pre>

<p>I na koniec rekurencyjne ustawienia właściwości folderu zawierającego konfigurowany raport. Znak <code>%</code> jest skrótowym zapisem polecenia <code>Foreach-Object</code>:</p>

<pre><code class="language-powershell">    function Set-FolderPolicy([string] $parent, [Proxy.Policy[]] $policies)
    {
        $folderPolicies = @()
        $folderPoliciesInherited = [ref] $false
        $folderPolicies = $global:proxy.GetPolicies($parent,
            $folderPoliciesInherited)
        foreach($policy in $policies){
            if($($folderPolicies | % {$_.GroupUserName}) -notcontains $policy.GroupUserName){
                $folderPolicies += $policy
            }
        }
        Write-Host &quot;Aktualizacja uprawnień folderu $parent&quot;
        $global:proxy.SetPolicies($parent, $folderPolicies)

        if($parent -eq $global:root){
            return
        }

        for($i = $parent.Length; 0, $i--){
            if($parent[$i] -eq &quot;/&quot;){
                $newParent = $parent.Substring(0, $i)
                if($newParent.Length -eq 0){
                    $newParent = &quot;/&quot;
                }
                Set-FolderPolicy $newParent $policies
                break
            }
        }
    }
</code></pre>

<p>Pamiętajmy o bardzo ważnym fakcie – uprawnienia folderu zawierający podfoldery i raporty są sumą uprawnień podfolderów i raportów!</p>

<h2 id="zakończenie">Zakończenie</h2>

<p>Uzbrojeni w taki skrypt możemy spokojnie wypłynąć na szerokie wody konfiguracyjne usług raportowych. Jedyne problemy jakie mogą nas spotkać dotyczyć będą sytuacji, kiedy będziemy próbowali skorzystać z protokołu https przy braku zaufanego certyfikatu. Nie ma bowiem możliwości potwierdzenia świadomego łączenia się z serwerem.</p>

<p>Osobom, które chciałyby spróbować swoich sił w wykorzystaniu języka PowerShell polecam pobranie darmowego <a href="http://www.powergui.org/" target="_blank">PowerGUI</a> umożliwiającego pisanie skryptów oraz zarządzanie (!) komputerem i nie tylko przy pomocy hierarchicznie zorganizowanych skryptów PowerShell. Warto również z sekcji <a href="http://www.powergui.org/kbcategory.jspa?categoryID=21" target="_blank">PowerPacks</a> pobrać pakiet <a href="http://www.powergui.org/entry.jspa?externalID=2045&amp;categoryID=54" target="_blank">SQL Server 2005 Reporting Services Power Pack</a> umożliwiający zarządzanie usługami raportującymi.</p>

<p>Grafika (schemat folderów) została wykonana przy pomocy <a href="http://bubbl.us" target="_blank">http://bubbl.us</a>.</p>

    </article>
    <nav aria-label="Related posts">
        <h4>Related Posts</h4>
        <ul>
            <li><a href="https://awasn.github.io/reporting-services-projekty-po-polsku/">Reporting Services - projekt(y) po polsku?</a></li>
            <li><a href="https://awasn.github.io/formsauthentication-w-reporing-services/">FormsAuthentication w Reporing Services</a></li>
        </ul>
    </nav>

    <nav class="pure-g post-previous-next" aria-label="Previous and next posts">
        <div class="pure-u-11-24 previous">
            <a href="https://awasn.github.io/implementacja-inversion-of-control-wersja-1-1/" aria-label="Previous post"><span aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-left"><polyline points="15 18 9 12 15 6"></polyline></svg></span></a>
            <a href="https://awasn.github.io/implementacja-inversion-of-control-wersja-1-1/">Implementacja Inversion of Control - wersja 1.1</a>
        </div>
        <div class="pure-u-2-24">&nbsp;</div>
        <div class="pure-u-11-24 next">
            <a href="https://awasn.github.io/zacznij-od-nowej-strony/">Zacznij od nowej strony</a>
            <a href="https://awasn.github.io/zacznij-od-nowej-strony/" aria-label="Next post"><span aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"><polyline points="9 18 15 12 9 6"></polyline></svg></span></a>
        </div>
    </nav>


        </main>

        <footer>
            <div class="center-aligned container">
                <p>Copyright &copy; 2007-2019 Arkadiusz Waśniewski. All Rights Reserved.</p>
            </div>
        </footer>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/languages/accesslog.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/languages/dockerfile.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/languages/dos.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/languages/go.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/languages/powershell.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/languages/routeros.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/languages/typescript.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/languages/yaml.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/languages/vbnet.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
    </body>
</html>