<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mobile on arkadiusz wasniewski blog</title>
    <link>https://awasn.github.io/tags/mobile/</link>
    <description>Recent content in Mobile on arkadiusz wasniewski blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 27 Jan 2009 12:38:00 +0100</lastBuildDate><atom:link href="https://awasn.github.io/tags/mobile/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Implementacja Inversion of Control - wersja 1.1</title>
      <link>https://awasn.github.io/implementacja-inversion-of-control-wersja-1-1/</link>
      <pubDate>Tue, 27 Jan 2009 12:38:00 +0100</pubDate>
      
      <guid>https://awasn.github.io/implementacja-inversion-of-control-wersja-1-1/</guid>
      <description>Od ostatniej notki opisującej wykorzystywany przeze mnie własnej produkcji kontener IoC wprowadziłem kilka modyfikacji czyniących rozwiązanie bardziej elastycznym, ale wciąż pozostające wierne podstawowym założeniom:
 Wydajne i łatwe w użyciu; Zminimalizowane użycie refleksji; Brak plików konfiguracyjnych.  Czymże jest kontener IoC Kontener IoC umożliwia programiście wprowadzenie w aplikacji luźnych powiązań pomiędzy obiektami. Programista rejestruje interfejsy i klasy abstrakcyjne wraz z typami implementującymi, instancjami lub procedurami tworzącymi instancje klas na żądanie:</description>
    </item>
    
    <item>
      <title>Rozwiązanie mobilne</title>
      <link>https://awasn.github.io/rozwiazanie-mobilne/</link>
      <pubDate>Thu, 11 Dec 2008 12:45:00 +0100</pubDate>
      
      <guid>https://awasn.github.io/rozwiazanie-mobilne/</guid>
      <description>Kilka miesięcy temu stałem się szczęśliwym posiadaczem projektu na przygotowanie kompletnego rozwiązania z zakresu szeroko pojętej sprzedaży dla &amp;ldquo;profesjonalnych&amp;rdquo; urządzeń mobilnych, czyli komputerów odpornych na niskie temperatury i kroploszczelne. Systemy operacyjne, które znalazły się w zasięgu projektu to:
 Microsoft Windows for Pocket PC 2003, Windows Mobile 2003; Windows Mobile 5.0 for Pocket PC, Windows Mobile 5.0 for Pocket PC Phone Edition; Windows Mobile 6 Classic, Windows Mobile 6 Professional.  Pod uwagę należało też brać możliwość pojawienia się w przyszłości konieczności działania programu w ramach Windows CE .</description>
    </item>
    
    <item>
      <title>Implementacja Inversion of Control</title>
      <link>https://awasn.github.io/implementacja-inversion-of-control/</link>
      <pubDate>Sun, 24 Aug 2008 11:49:00 +0200</pubDate>
      
      <guid>https://awasn.github.io/implementacja-inversion-of-control/</guid>
      <description>Jedną z cech dobrego oprogramowania są luźne powiązania pomiędzy klasami. Droga do tego celu ciężka i kręta. Bez dwóch zdań. Wśród technik i wzorców, które należy w tym celu stosować znajdują się fabryki (Factory) oraz lokalizatory usług (Service Locator), dzięki którym tworzeniem instancji obiektów czy implementacji zadanych interfejsów zajmują się wyspecjalizowane klasy. Z tworzeniem obiektów, w kontekście wymienionych powyżej praktyk, związane są następujące koncepcje:
 Inversion of Control - instancje klas pobierane są z zewnętrznych zasobów; Dependency Injection - tworzenie instancji zleca się zewnętrznemu obiektowi (kontenerowi) znającemu zależności pomiędzy właściwymi klasami.</description>
    </item>
    
    <item>
      <title>Debugger.Break ładuje pakiety</title>
      <link>https://awasn.github.io/debugger-break-laduje-pakiety/</link>
      <pubDate>Wed, 04 Jun 2008 13:34:00 +0200</pubDate>
      
      <guid>https://awasn.github.io/debugger-break-laduje-pakiety/</guid>
      <description>W czasie testowania oprogramowania mobilnego zdarza się, iż zdalne debuggowie przestaje funkcjonować. Obok ustawionych punktów wstrzymania pojawia się zaś ikona, która po najechaniu kursorem wyświetla komunikat, iż zdalna praca jest niemożliwa, ponieważ dany pakiet nie został załadowany. Co ciekawe dalej może rozpocząć wykonywanie krokowe aplikacji. Restart Visual Studio w takiej sytuacji nie pomaga.
Okazuje się, iż rozwiązanie problemu jest trywialne. Należy w kodzie programu, gdzie chcemy ustawić punkt wstrzymania wstawić następujące polecenie:</description>
    </item>
    
    <item>
      <title>Model zabezpieczeń w Windows Mobile a urządzenia typu Smartphone</title>
      <link>https://awasn.github.io/model-zabezpieczen-w-windows-mobile-a-urzadzenia-typu-smartphone/</link>
      <pubDate>Wed, 27 Feb 2008 16:53:00 +0100</pubDate>
      
      <guid>https://awasn.github.io/model-zabezpieczen-w-windows-mobile-a-urzadzenia-typu-smartphone/</guid>
      <description>Wraz z systemami Windows Mobile 5.0 i Windows Mobile 6 wprowadzono nowych model zabezpieczeń (security model), który umożliwia przy pomocy zasad (policies), ról (roles) oraz certyfikatów (certificates) kontrolowanie konfiguracji, zdalnego dostępu oraz wykonywanie aplikacji na urządzeniu mobilnym. Ograniczeniu podlega dostęp do zasobów takich jak przestrzeń dyskowa, rejestr systemu czy API. Na podstawie ustalonego poziomu zabezpieczeń, program może być uruchomiony z uprawnieniami:
 Uprzywilejowany - możliwość wywoływania API bez ograniczeń, dokonywania modyfikacji rejestru, pełny dostęp do systemu plików; Normalny - brak możliwości wywoływania API newralgicznych dla właściwego działania systemu, brak możliwości modyfikacji niektórych gałęzi rejestru, ograniczenia w dostępie do systemu plików.</description>
    </item>
    
    <item>
      <title>HTTP - Własny serwer komunikacji. Część #1 - Wstęp</title>
      <link>https://awasn.github.io/http-wlasny-serwer-komunikacji-cz1-wstep/</link>
      <pubDate>Mon, 14 Jan 2008 22:45:00 +0100</pubDate>
      
      <guid>https://awasn.github.io/http-wlasny-serwer-komunikacji-cz1-wstep/</guid>
      <description>Budując rozwiązanie, które wymaga wymiany informacji z aplikacjami uruchomionymi na innych maszynach możemy skorzystać z kilku propozycji, jakich dostarcza platforma .NET. Są to między innymi gniazdka (sockets), .NET Remoting, Usługi Sieciowe (Web Services), kolejki wiadomości (MSMQ) czy łączący i uzupełniający większość z tych rozwiązań Windows Communication Foundation (WCF). Oczywiście część z tych metod działa praktycznie tylko wtedy, jeśli obie strony oparte są o .NET (.NET Remoting czy net.tcp z WCF). Inne znów mają problemy jeśli wychodzimy poza obręb danej sieci (.</description>
    </item>
    
    <item>
      <title>Loopa TV</title>
      <link>https://awasn.github.io/loopa-tv/</link>
      <pubDate>Fri, 14 Sep 2007 13:43:00 +0200</pubDate>
      
      <guid>https://awasn.github.io/loopa-tv/</guid>
      <description>Programując urządzenia mobilne człowiek posiada naturalną potrzebę uruchomienia kodu na takim komputerze (komputerku?). W ramach standardowego środowiska programisty nie ma z tym zazwyczaj problemu. Bierzemy dok (vel kołyskę), wkładamy do niego urządzenie i łączymy z PC przy pomocy kabla USB. Działa. Jakaś komunikacja protokołem TCP z komputerem stacjonarnym? Nie ma problemu, działa. Robimy to samo w terenie, albo bez sieci (nie mając połączenia)&amp;hellip; no&amp;hellip; nie działa. Nie da rady skomunikować się poprzez TCP z urządzenia mobilnego.</description>
    </item>
    
    <item>
      <title>Mobilne MFC a protokół HTTP</title>
      <link>https://awasn.github.io/mobilne-mfc-a-protokol-http/</link>
      <pubDate>Fri, 31 Aug 2007 10:37:00 +0200</pubDate>
      
      <guid>https://awasn.github.io/mobilne-mfc-a-protokol-http/</guid>
      <description>Wakacje nie wakacje, szukanie pracy czy nie, wypadałoby zadbać o swój blog. Dzisiaj trochę z innej beczki (chociaż jak się zastanowić to nie znajduję argumentów czemu z innej niby beczki) ale wciąż w temacie mobilnym. Po to aby nie zapomnieć.
Osoby programujące urządzenia mobilne i korzystające z klas MFC w ramach Microsoft eMbedded Visual C++ i chcące do wymiany danych wykorzystać protokół HTTP natkną się na niemiłą niespodziankę. Każda odebrana odpowiedź z serwera zmniejsza nam ilość dostępnej pamięci na dysku.</description>
    </item>
    
    <item>
      <title>Dobre praktyki w projektowaniu aplikacji mobilnych</title>
      <link>https://awasn.github.io/dobre-praktyki-w-projektowaniu-aplikacji-mobilnych/</link>
      <pubDate>Mon, 23 Apr 2007 14:03:00 +0200</pubDate>
      
      <guid>https://awasn.github.io/dobre-praktyki-w-projektowaniu-aplikacji-mobilnych/</guid>
      <description>W ostatnią sobotę (21.04.2007) na VI spotkaniu Warszawskiej Grupy .NET miałem przyjemność wystąpić z prezentacją dotyczącą wzorców projektowych, które warto zastosować programując urządzenia mobilne. Sam plik zawierający slajdy to oczywiście za mało, więc poniżej kilka dodatkowych opisów.
Service Locator, slajdy 18 i 19 Klasa ObjectLocator oparta o wzorzec ServiceLocator została, ze względu na chęć umieszczenia wszystkiego na slajdzie, właściwościach pozbawiona możliwości nadawania nowych wartości. Rzeczywista klasa powinna taką możliwość udostępniać - chociażby w celu umożliwienia napisania klas testujących.</description>
    </item>
    
  </channel>
</rss>
