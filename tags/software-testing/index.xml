<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Software testing on arkadiusz wasniewski blog</title>
    <link>https://awasn.github.io/tags/software-testing/</link>
    <description>Recent content in Software testing on arkadiusz wasniewski blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 17 Mar 2009 12:02:00 +0100</lastBuildDate><atom:link href="https://awasn.github.io/tags/software-testing/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>TDD versus BDD</title>
      <link>https://awasn.github.io/tdd-versus-bdd/</link>
      <pubDate>Tue, 17 Mar 2009 12:02:00 +0100</pubDate>
      
      <guid>https://awasn.github.io/tdd-versus-bdd/</guid>
      <description>Testy, testy, testy. Najpierw. Przed właściwym kodem. A może po? Co testować? Wszystko? Jeśli tworzymy zbiór publicznych typów (interfejs pakietu) to testowane powinno być jak najbardziej wszystko i to szczegółowo. To jest Test Dirven Driven Development (TDD). Część publiczna jest naszym kontraktem informującym jaki będzie rezultat operacji przy określonych parametrach. Niestety w chwili obecnej możliwości języków programowania są ograniczone jeśli chodzi o precyzyjne definiowanie dozwolonych wartości przekazywanych do metod i właściwości.</description>
    </item>
    
    <item>
      <title>Rozwiązanie mobilne</title>
      <link>https://awasn.github.io/rozwiazanie-mobilne/</link>
      <pubDate>Thu, 11 Dec 2008 12:45:00 +0100</pubDate>
      
      <guid>https://awasn.github.io/rozwiazanie-mobilne/</guid>
      <description>Kilka miesięcy temu stałem się szczęśliwym posiadaczem projektu na przygotowanie kompletnego rozwiązania z zakresu szeroko pojętej sprzedaży dla &amp;ldquo;profesjonalnych&amp;rdquo; urządzeń mobilnych, czyli komputerów odpornych na niskie temperatury i kroploszczelne. Systemy operacyjne, które znalazły się w zasięgu projektu to:
 Microsoft Windows for Pocket PC 2003, Windows Mobile 2003; Windows Mobile 5.0 for Pocket PC, Windows Mobile 5.0 for Pocket PC Phone Edition; Windows Mobile 6 Classic, Windows Mobile 6 Professional.  Pod uwagę należało też brać możliwość pojawienia się w przyszłości konieczności działania programu w ramach Windows CE .</description>
    </item>
    
    <item>
      <title>Debugger.Break ładuje pakiety</title>
      <link>https://awasn.github.io/debugger-break-laduje-pakiety/</link>
      <pubDate>Wed, 04 Jun 2008 13:34:00 +0200</pubDate>
      
      <guid>https://awasn.github.io/debugger-break-laduje-pakiety/</guid>
      <description>W czasie testowania oprogramowania mobilnego zdarza się, iż zdalne debuggowie przestaje funkcjonować. Obok ustawionych punktów wstrzymania pojawia się zaś ikona, która po najechaniu kursorem wyświetla komunikat, iż zdalna praca jest niemożliwa, ponieważ dany pakiet nie został załadowany. Co ciekawe dalej może rozpocząć wykonywanie krokowe aplikacji. Restart Visual Studio w takiej sytuacji nie pomaga.
Okazuje się, iż rozwiązanie problemu jest trywialne. Należy w kodzie programu, gdzie chcemy ustawić punkt wstrzymania wstawić następujące polecenie:</description>
    </item>
    
    <item>
      <title>Stub, Fake, Mock</title>
      <link>https://awasn.github.io/stub-fake-mock/</link>
      <pubDate>Mon, 12 May 2008 12:42:00 +0200</pubDate>
      
      <guid>https://awasn.github.io/stub-fake-mock/</guid>
      <description>Stub – klasa zawierająca metody, które nic nie robią. Główne zadanie takiej klasy to umożliwienie kompilacji programu; Fake – klasa zawierająca metody, które zwracają ściśle określone wartości, np. wpisane na sztywno w kod klasy; Mock – klasa, dla której możemy określić jakie metody czy właściwości mogą być wywoływane, jakie wartości mają być przyjmowane i zwracane.  Mała aktualizacja po publikacji posta i dyskusji nad nim: powyższy opis nie do końca jest jednak poprawny.</description>
    </item>
    
    <item>
      <title>ReSharper ostrzega - Possible NullReferenceException</title>
      <link>https://awasn.github.io/resharper-ostrzega-possible-nullreferenceexception/</link>
      <pubDate>Wed, 09 Jan 2008 23:15:00 +0100</pubDate>
      
      <guid>https://awasn.github.io/resharper-ostrzega-possible-nullreferenceexception/</guid>
      <description>Kontekst rozważań jest następujący. Metoda (wersja uproszczona poniżej) buduje ściśle określoną sekwencję sterującą. Dokumentacja mówi, iż sekwencja ta musi zawierać dokładnie osiem parametrów oddzielonych średnikiem. Dopuszcza się przy tym parametry puste. Użytkownik nie jest karany (np. wyjątek) za brak parametrów. Nie spotka go też przykra niespodzianka, jeśli poda zbyt dużo parametrów.
public void SampleReport(string[] names) { const byte maxNumberOfNames = 8; int numberOfNames = names == null ? 0 : names.</description>
    </item>
    
    <item>
      <title>Herr Mock i Frau Command</title>
      <link>https://awasn.github.io/herr-mock-i-frau-command/</link>
      <pubDate>Thu, 21 Jun 2007 17:01:00 +0200</pubDate>
      
      <guid>https://awasn.github.io/herr-mock-i-frau-command/</guid>
      <description>Sławetny wzorzec Model-View-Presenter ma swoje zalety, ale ma i swoje uciążliwości. Jedna z wykorzystywanych przeze mnie implementacji tego wzorca zakłada, iż widok będzie posiadał funkcję umożliwiającą dodawanie do menu widoku kolejnych poleceń, które będą zawierały metody zwrotne wywoływane jako reakcja w przypadku wykonania polecenia. Jest to o tyle konieczne, iż np. formularz wyświetlający tabelę może zachowywać się różnie (obsługiwać różne zestawy poleceń) w zależności od danych, które ma zaszczyt prezentować. Weźmy pod uwagę fragment prezentera umożliwiającego identyfikację użytkownika.</description>
    </item>
    
    <item>
      <title>Wyjątki</title>
      <link>https://awasn.github.io/wyjatki/</link>
      <pubDate>Tue, 15 May 2007 13:19:00 +0200</pubDate>
      
      <guid>https://awasn.github.io/wyjatki/</guid>
      <description>Jednym z elementów podlegających testowaniu jest sprawdzanie zachowania kodu w przypadku otrzymania nieprawidłowych danych. Reakcją na tego typu zdarzenia może być wyrzucanie wyjątków. Czasem jednak mogą powstać z tego tytułu pewne komplikacje. Załóżmy, że mamy do przetestowania poniższą klasę:
class CommandLibraryLocator : ICommandLibraryLocator { private ILibraryRepository libraryRepository; public CommandLibraryLocator(ILibraryRepository libraryRepository) { if (libraryRepository == null) throw new ArgumentNullException(&amp;#34;libraryRepository&amp;#34;); this.libraryRepository = libraryRepository; } public string GetPath(UserIdentity identity) { if (identity == null) throw new ArgumentNullException(&amp;#34;identity&amp;#34;); .</description>
    </item>
    
  </channel>
</rss>
