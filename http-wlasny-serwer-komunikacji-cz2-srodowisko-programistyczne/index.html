<!doctype html><html lang=pl-pl><head><meta name=theme-color content="#405365"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.83.1"><meta name=description content="Implementacja w pełni funkcjonalnego serwera komunikacji korzystającego z protokołu HTTP, opartego o śodowisko ASP.NET oraz IIS"><title>HTTP - Własny serwer komunikacji. Część #2 - Środowisko programistyczne - arkadiusz wasniewski blog</title><link rel=canonical href=https://awasn.github.io/http-wlasny-serwer-komunikacji-cz2-srodowisko-programistyczne/><link rel=prev title="Określanie dnia tygodnia z pogardą dla DATEFIRST" href=https://awasn.github.io/okreslanie-dnia-tygodnia-z-pogarda-dla-datefirst/><link rel=next title="Hook scripts w C#" href=https://awasn.github.io/hook-scripts-w-csharp/><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/pure-min.css integrity="sha256-Q0zCrUs2IfXWYx0uMKJfG93CvF6oVII21waYsAV4/8Q=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-min.css integrity="sha256-YqnnS/cQ7vE7gfVjdfx+JMi5EFD6m6Zqdemj81rs6PU=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/styles/agate.min.css><link rel=stylesheet href=https://awasn.github.io/awasn.min.f45a909800924faa836a73b82a1d4cb352f8053134a426a9dcafa61cf6a8c5d0.css integrity="sha256-9FqQmACST6qDanO4Kh1Ms1L4BTE0pCap3K+mHPaoxdA="></head><body><header><nav class=container><div class="pure-menu pure-menu-horizontal"><a class="pure-menu-heading pure-menu-link" href=https://awasn.github.io/>wasniewski</a><ul class="right pure-menu-list"><li class=pure-menu-item><a class=pure-menu-link href=https://awasn.github.io/blog/>blog</a></li><li class=pure-menu-item><a class=pure-menu-link href=https://awasn.github.io/categories/>categories</a></li><li class=pure-menu-item><a class=pure-menu-link href=https://awasn.github.io/tags/>tags</a></li><li class=pure-menu-item><a class=pure-menu-link href=https://awasn.github.io/about/>about</a></li></ul></div></nav></header><main class=container><aside class=post-published><p>This post was originally published on <a href=http://zine.net.pl/blogs/arkadiusz_wasniewski/archive/2008/01/27/http-w-asny-serwer-komunikacji-cz-2-rodowisko-programistyczne.aspx target=_blank>zine.net.pl</a> on 27 January 2008 22:12 +0100</p></aside><article><header><h1>HTTP - Własny serwer komunikacji. Część #2 - Środowisko programistyczne</h1><div class=post-metadata><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>27 January 2008 22:12 +0100
&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit"><path d="M20 14.66V20a2 2 0 01-2 2H4a2 2 0 01-2-2V6a2 2 0 012-2h5.34"/><polygon points="18 2 22 6 12 16 8 16 8 12 18 2"/></svg>
17 September 2018 13:42 +0200
&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
12 min read</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-folder"><path d="M22 19a2 2 0 01-2 2H4a2 2 0 01-2-2V5a2 2 0 012-2h5l2 3h9a2 2 0 012 2z"/></svg><a href=https://awasn.github.io/categories/development>Development</a>, <a href=https://awasn.github.io/categories/tools>Tools</a>
&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg>
<a href=https://awasn.github.io/tags/.net>.NET</a>, <a href=https://awasn.github.io/tags/asp.net>ASP.NET</a>, <a href=https://awasn.github.io/tags/iis>IIS</a>, <a href=https://awasn.github.io/tags/virtualization>Virtualization</a></div></div></header><p>Zasadniczo całe rozwiązanie zbudowane będzie przy pomocy Microsoft Visual Studio 2005 Professional Edition w oparciu o ASP.NET Web Application jako typ projektu. Użytkownicy wersji Express będą niestety zmuszeni dokonać konwersji do projektu Web Site. Dostarczany z Visual Studio serwer WWW w zupełności wystarczy do uruchomienia prezentowanego rozwiązania. Z racji wybranego środowiska operować będziemy na platformie .NET w wersji 2.0. Nie mniej jednak bez żadnych zmian prezentowane oprogramowanie będzie działało również w wersji 1.1 oraz 3.x platformy .NET. W kolejnych częściach nie będziemy się też wgłębiać w tajniki systemu Windows Server 2008 oraz IIS 7 dostępnych obecnie w wersji Release Candidate. Naszą bazę &ldquo;dydaktyczną&rdquo; będzie stanowił Windows Server 2003 R2.</p><h2 id=biblioteki>Biblioteki</h2><h3 id=nlog>NLog</h3><p>Na różnych etapach tworzenia oprogramowania oraz w czasie produkcyjnego wykorzystywania rozwiązania istnieje konieczność rejestrowania (logowania) działania aplikacji. Można do tego celu wykorzystać standardowe możliwości platformy .NET. Można w tym celu skorzystać z <a href=http://msdn.microsoft.com/entlib>Enterprise Library</a>, a konkretnie z części nazywanej <a href=http://zine.net.pl/blogs/arkadiusz_wasniewski/archive/2007/09/24/konkurs-enterprise-library-logging-lab.aspx>Logging Application Block</a>. W budowanym rozwiązaniu będziemy wykorzystywać jeszcze inne rozwiązanie, mianowicie napisaną przez Jarka Kowalskiego bibliotekę <a href=http://nlog-project.org>NLog</a>. Na stronach projektu można zapoznać się z napisanym po polsku wprowadzeniem (<code>http://www.nlog-project.org/wprowadzenie.html</code>) do korzystania z biblioteki. Polecam. Tym bardziej, że NLog może też być wykorzystywany na platformie .NET Compact Framework.</p><h2 id=narzędzia>Narzędzia</h2><h3 id=wfetch>WFetch</h3><p>WFetch to jedno z ciekawszych narzędzi. Zezwala na wszechstronną diagnostykę aplikacji Web poprzez umożliwienie użytkownikowi wysyłanie i oglądanie na poziomie przesyłanych pakietów HTTP komunikacji pomiędzy programem a serwerem WWW. Program można pobrać między innymi ze strony <a href=https://support.microsoft.com/en-us/help/284285/how-to-use-wfetch-exe-to-troubleshoot-http-connections>https://support.microsoft.com/en-us/help/284285/how-to-use-wfetch-exe-to-troubleshoot-http-connections</a>. Poniżej przykładowy efekt działania:</p><figure><img class=pure-img src=https://awasn.github.io/http-wlasny-serwer-komunikacji-cz2-srodowisko-programistyczne/images/WFetch.png alt="WFetch - żądanie i odpowiedź zwrotna"><figcaption><h4>WFetch - żądanie i odpowiedź zwrotna</h4></figcaption></figure><p>Jak widzimy do aplikacji Web uruchomionej lokalnie na porcie 1395 (serwer testowy Visual Studio) wysyłamy żądanie wyświetlenia domyślnej strony. Reakcja serwera jest zgodna z naszymi oczekiwaniami. Dostajemy bowiem jako odpowiedź zawartość właściwego pliku.</p><h3 id=network-monitor>Network Monitor</h3><p>W czasie tworzenia rozwiązań przesyłających dane poprzez sieć dobrze jest mieć możliwość sprawdzenia poprawności wykonanej implementacji, czy informacje są dobrze zabezpieczone etc. W tym celu można wykorzystać narzędzie <a href="https://www.microsoft.com/en-us/download/details.aspx?id=4865">Microsoft Network Monitor</a>, które umożliwia obserwowanie (przechwytywanie) oraz analizowanie ruchu sieciowego. Informacje dotyczące konfiguracji oraz użytkowania tej aplikacji można znaleźć na blogu <a href=http://blogs.technet.com/netmon>Network Monitor</a> oraz oczywiście w pomocy programu.</p><p>Po zainstalowaniu i uruchomieniu programu po lewej stronie, w części <strong>Capture Network Traffic</strong>, klikamy przycisk <strong>Create a new capture tab&mldr;</strong> dzięki czemu będziemy mogli rozpocząć przechwytywanie ruchu sieciowego. Aby nie zostać zalanym informacjami, w utworzonej zakładce, w sekcji <strong>Display Filter</strong> wpisujemy <strong>protocol.HTTP</strong> i klikamy <strong>Apply</strong>. Pozwoli nam to ograniczyć wyświetlane dane tylko do protokołu HTTP. Klawisz F10 uruchamia nasłuch, F11 zatrzymuje.</p><figure><img class=pure-img src=https://awasn.github.io/http-wlasny-serwer-komunikacji-cz2-srodowisko-programistyczne/images/Network_Monitor_Request.png alt="Network Monitor - Żądanie wyświetlenia domyślnej strony"><figcaption><h4>Network Monitor - Żądanie wyświetlenia domyślnej strony</h4></figcaption></figure><p>Powyższy zrzut ekranu pokazuje wysłane do serwera żądanie wyświetlenie domyślnej strony dla aplikacji Sample1.</p><h2 id=wirtualizacja>Wirtualizacja</h2><p>W przypadku tworzenia rozwiązań sieciowych pewnym problemem może być testowania rozwiązania. Chodzi mi tutaj przede wszystkich o kwestie przesyłania danych, poprawności implementacji czy bezpieczeństwo. Ruch sieciowy najłatwiej jest analizować pomiędzy dwoma komputerami. Czasem w możliwościach ogranicza nas system operacyjny. Np. Windows XP Home Edition nie posiada serwera IIS. Rozwiązaniem tych problemów, i nie tylko tych, jest wirtualizacja czyli skorzystanie z preinstalowanych systemów umożliwiających nam w zdefiniowanym okresie czasu między innymi testowanie i sprawdzanie poprawności działania aplikacji Web. Z wirtualizacją wiążą się dwa pojęcia. Komputer na którym uruchamiamy oprogramowanie wirtualizacyjne nazywamy hostem. System uruchamiany zaś w ramach tego oprogramowania to gość.</p><p>Aby móc skorzystać z możliwości maszyn wirtualnych musimy mieć zainstalowane oprogramowanie ową wirtualizację umożliwiające. Polecam dwa. Pierwsze z nich to <a href=https://vmware.com>VMware Server</a>, drugie zaś to <a href="https://www.microsoft.com/en-us/download/details.aspx?id=3702">Virtual PC</a>. Oba rozwiązania są bezpłatne. Co prawda dostarczane przez Microsoft wirtualne dyski systemów zawierających Internet Information Services wymagają aplikacji Virtual Server (<code>http://www.microsoft.com/windowsserversystem/virtualserver</code>), ale jeśli ktoś ma Windows XP Home Edition to i tak tego programu nie uruchomi. Na szczęście zarówno VMware Server 1.0 jak i Virtual PC 2007 bez problemów umożliwiają uruchomienie tych maszyn wirtualnych a pojawiające się na początku z tego tytułu ostrzeżenia można spokojnie zignorować. Nie polecam obecnie instalowania VMware Server w wersji 2.0 Beta.</p><p>Aby pobrać maszynę wirtualną należy wejść na stronę <code>http://www.microsoft.com/vhd</code>. Z pośród dostępnych rozwiązań w chwili obecnej możemy wybrać między innymi <a href="https://www.microsoft.com/en-us/download/details.aspx?id=19727">Windows Server 2003 R2</a> w wersji Enterprise. Pobrane pliki należy rozpakować do wybranej lokalizacji. Poniżej opis dodania, konfiguracji i uruchomienia tego systemu w ramach obu najważniejszych aplikacji umożliwiających wirtualizację.</p><h3 id=dodawanie-maszyny-wirtualnej>Dodawanie maszyny wirtualnej</h3><p>Pierwszy krok na drodze do szczęścia to podłączenie maszyny wirtualnej do aplikacji wirtualizującej. W programie Virtual PC z menu <strong>File</strong> wybieramy polecenie <strong>New Virtual Machine Wizard</strong> i klikamy <strong>Next</strong>. Zaznaczamy opcję <strong>Add an existing virtual machine</strong>. W następnym oknie znajdujemy w wybranej lokalizacji plik <strong>WS03R2EE.vmc</strong> (jeśli pobraliśmy oczywiście Windows Server 2003 R2). Zakończenie kreatora umożliwi przejście do skonfigurowania dodanej maszyny wirtualnej. Na liście zaznaczamy <strong>WS03R2EE</strong> i klikamy przycisk <strong>Settings</strong>. W ustawieniach należy wziąć pod uwagę kilka parametrów:</p><ul><li><strong>Memory</strong> - im więcej tym lepiej. To oczywiście zależy od ilości pamięci zainstalowanej na naszym fizycznym komputerze;</li><li><strong>Networking</strong> - dostęp do sieci. Domyślnie ustawiony jest brak połączenia. Opis konfiguracji tego parametru znajdziemy w dalszej części artykułu;</li><li><strong>Shared Folder</strong> - współdzielone między komputerem fizycznym a wirtualnym zasoby w postaci katalogów i plików. Opcja ta dostępna jest zazwyczaj dopiero po zainstalowaniu w systemie wirtualnym specjalnych dodatków integrujących. Ewaluacyjna wersja serwera te dodatki już posiada.</li></ul><p>Przed uruchomieniem maszyny wirtualnej należy jeszcze w <strong>File -> Options</strong> w sekcji <strong>Keyboard</strong> kliknąć pole tekstowe <strong>Current host key</strong> a następnie wcisnąć na klawiaturze lewy klawisz Alt. W przeciwnym razie, przy domyślnie ustawionym klawiszu jakim jest prawy Alt nie będziemy mogli używać polskich znaków.</p><p>Pierwsze uruchomienie maszyny wirtualnej to automatyczna konfiguracja i restart. Po ponownym uruchomieniu możemy zalogować się do serwera. Pamiętajmy, iż zamiast Ctrl-Alt-Del używamy Alt-Del. Nazwa: Administrator. Hasło: Evaluation1.</p><p>W aplikacji VMware Server, podobnie jak w Virtual PC, musimy wpierw wirtualną maszynę dodać. Z menu <strong>File</strong> wybieramy polecenie <strong>Import&mldr;</strong> a następnie klikamy dwa razy przycisk <strong>Next</strong>. W oknie <strong>Specify the Source Image</strong> wybieramy plik konfiguracyjny maszyny wirtualnej (w naszym przypadku <strong>WS03R2EE.vmc</strong>) i klikamy <strong>Next</strong>. Import oznacza utworzenie kopii maszyny wirtualnej w formacie VMware - należy wziąć to pod uwagę i zadbać w o odpowiednią ilość wolnej przestrzeni na dysku.</p><figure><img class=pure-img src=https://awasn.github.io/http-wlasny-serwer-komunikacji-cz2-srodowisko-programistyczne/images/VMware_Server_Console.png alt="VMware Server - konsola zarządzająca"><figcaption><h4>VMware Server - konsola zarządzająca</h4></figcaption></figure><p>Jeśli import zakończy się klęską, należy sprawdzić, klikając łącze <strong>Show the logfile</strong>, czy w logu znajduje się informacja następującej treści: <em>TranslateError: original Description is Failed to initialize MSXML</em>. Tego typu komunikat oznacza, iż w systemie brakuje parsera XML w wersji 2.6, 3.0 lub 4.0. Stosowne wersje można pobrać ze stron firmy Microsoft. Np. wersję MSXML 4.0 Service Pack 2 można znaleźć <a href="https://www.microsoft.com/en-us/download/details.aspx?id=19662">tutaj</a>. Należy pobrać plik <a href=http://download.microsoft.com/download/9/6/5/9657c01e-107f-409c-baac-7d249561629c/msxml.msi>msxml.msi</a> i zainstalować oprogramowanie.</p><p>Kolejny problem jaki może się pojawić to niemożność ustalenia przez importer VMware Server poprawnej ścieżki dostępu do wirtualnego dysku <strong>Win2k3R2EE.vhd</strong>. Należy wówczas zmodyfikować plik <strong>WS03R2EE.vmc</strong> wyszukując w nim element</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml>    <span style=color:#f92672>&lt;absolute</span> <span style=color:#a6e22e>type=</span><span style=color:#e6db74>&#34;string&#34;</span><span style=color:#f92672>&gt;</span>Win2k3R2EE.vhd<span style=color:#f92672>&lt;/absolute&gt;</span>
</code></pre></div><p>i wpisując pełną ścieżkę dostępu do wirtualnego dysku np.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml>    <span style=color:#f92672>&lt;absolute</span> <span style=color:#a6e22e>type=</span><span style=color:#e6db74>&#34;string&#34;</span><span style=color:#f92672>&gt;</span>d:\Windows_Server_2003_RS\Win2k3R2EE.vhd<span style=color:#f92672>&lt;/absolute&gt;</span>
</code></pre></div><p>W sumie zawsze mi się wydawało, iż bezwzględna ścieżka powinna zawierać literę dysku oraz pełną ścieżkę dostępu do danych zasobów. No ale&mldr;</p><p>Tak jak w przypadku Virtual PC powinniśmy przydzielić maszynie wirtualnej odpowiednią ilość pamięci. Jak mamy fantazję, to możemy z serwera zrobić nawet maszynę o dwóch procesorach.</p><p>Aby opuścić przestrzeń wirtualnego systemu należy nacisnąć kombinację Ctrl-Alt. Wysłanie kombinacji klawiszy Ctrl-Alt-Del można osiągnąć poprzez wybranie w menu VMware Server polecenia <strong>VM -> Send Ctrl+Alt+Del</strong>. Mając uruchomiony system powinniśmy w celu ułatwienia sobie życia zainstalować VMware Tools. Klikamy prawym klawiszem na zakładkę WS03R2EE lub na nazwę naszej maszyny na liście zainstalowanych systemów i wybieramy polecenie <strong>Install VMware Tools&mldr;</strong>. Dodatki te umożliwią nam między innymi korzystanie z maszyny wirtualnej tak jak z każdego innego programu, bez konieczności używania kombinacji Ctrl-Alt. Niestety brak jest współdzielonych folderów.</p><p>Po zainstalowaniu VMware Tools mogą wystąpić problemy jeśli korzystamy z myszki podpiętej do portu USB. W takim wypadku należy dodatki odinstalować i zainstalować jeszcze raz wybierając <strong>Custom</strong> jako typ instalacji. Z listy <strong>VMware Device Drivers</strong> wykluczamy wówczas sterownik do myszki. Czasem również może zaistnieć potrzeba odrzucenia sterownika grafiki.</p><h3 id=połączenia-sieciowe>Połączenia sieciowe</h3><p>Po podłączeniu maszyny wirtualnej powinniśmy skonfigurować połączenia sieciowe. Ze względu na sposób w jaki będziemy chcieli wykorzystywać wirtualny system mamy do wyboru dwie opcje.</p><p>Pierwsza polega na podłączeniu systemu gościa bezpośrednio do karty fizycznej hosta. Maszyna wirtualna będzie wtedy widziana w sieci jako osobny komputer. Jednocześnie będziemy posiadać z niej pełny dostęp do Internetu. W programie Virtual PC wybieramy polecenie <strong>Settings</strong> dla danej maszyny wirtualnej, przechodzimy do parametru <strong>Networking</strong> i zmieniamy wartość domyślną <strong>Not Connected</strong> (brak połączenia) na istniejącą w komputerze hosta kartę sieciową. Sposób przypisania adresu do karty sieciowej systemu wirtualnego zależy ściśle od sposobu adresowania w sieci komputera hosta. Jeśli jest ono statyczne powinniśmy karcie sieciowej systemu gościa również ręcznie przypisać adres. W VMware Server natomiast wybieramy dla maszyny wirtualnej polecenie <strong>Edit virtual machine settings</strong>. Przechodzimy do parametru <strong>Ethernet</strong> i w sekcji <strong>Network Connection</strong> zaznaczamy <strong>Bridged: Connected directly to the physical network</strong>. Co ciekawe w czasie instalacji programu VMware Server do systemu dodawane są wirtualne karty sieciowe. Dzięki temu możemy również zaznaczyć opcję <strong>Custom: Specific virtual network</strong> i z listy wybrać wirtualny adapter <strong>VMnet0 (default Bridged)</strong>. Zachowanie interfejsu VMnet0 można określić w programie Manage Virtual Networks. W zakładce <strong>Host Virtual Network Mapping</strong> tego programu wyświetlana jest lista możliwych do obsłużenia adapterów. Domyślnie interfejs VMnet0 przypisaną ma wartość, dzięki której będzie on wskazywał na aktywną kartę sieciową komputera fizycznego. Możemy jednak wybrać z listy dowolną istniejącą w komputerze hoście kartę sieciową wiążąc ją na stałe z interfejsem VMnet0. Dzięki temu otrzymamy taki sam efekt jak w ustawieniach Virtual PC. Warto też zajrzeć na zakładkę <strong>Automatic Bridging</strong> gdzie możemy między ustalić wyjątki, czyli wybrać adaptery, które nie będą mogły być używane dla opcji bezpośredniego podłączania maszyny wirtualnej do karty sieciowej hosta.</p><p>Drugi sposób konfiguracji połączeń sieciowych polega na zbudowaniu własnej podsieci. Maszyna wirtualna będzie wówczas izolowana od istniejącej już sieci (zwiększone bezpieczeństwo) i nie będzie miała dostępu do Internetu (można to oczywiście zmienić poprzez włączenie współdzielenia połączenia internetowego po stronie komputera hosta). Zadanie polega na tym, aby system wirtualny i rzeczywisty miały adresy kart z tego samego zakresu, przy braku modyfikacji ustawień dla istniejących kart sieciowych. Rozwiązanie jest bardziej skomplikowane niż bezpośrednie podłączenie do aktywnej karty sieciowej. Jeśli korzystamy z Virtual PC musimy zainstalować w systemie komputera hosta <a href=https://awasn.github.io/loopa-tv/>kartę połączenia zwrotnego</a>. Karta ta umożliwia budowanie sieci wirtualnych. W Windows XP w <strong>Panelu sterowania</strong> wybieramy <strong>Dodaj sprzęt</strong> i klikamy <strong>Dalej</strong>. Uruchomiony kreator będzie starał się znaleźć dodatkowy sprzęt w naszym komputerze. Następnie wyświetlony zostanie formularz, w którym zaznaczamy, iż szukany sprzęt jest już zainstalowany i przechodzimy do następnego okna. Z listy wybieramy <strong>Dodaj nowe urządzenie sprzętowe</strong> i przechodzimy dalej. Następnie zaznaczamy opcję, która umożliwi wybranie sprzętu ręcznie z listy. W kolejnych oknach wybieramy jako sprzęt karty sieciowe, producenta Microsoft i Kartę Microsoft Loopback. W przypadku VMware Server wszystkie niezbędne karty są już przez tę aplikację zainstalowane.</p><p>Mając już zainstalowane odpowiednie adaptery sieciowe, musimy je teraz skonfigurować. Zacznijmy od Virtual PC. W ustawieniach maszyny wirtualnej parametr <strong>Networking</strong> powinien przyjąć wartość <strong>Karta Microsoft Loopback</strong>. W <strong>Połączeniach sieciowych</strong> komputera fizycznego, we właściwościach karty Loopback, a następnie protokołu internetowego TCP/IP zaznaczamy opcję <strong>Użyj następującego adresu IP</strong>. Teraz musimy wpisać adres sieciowy. Najlepiej, aby był on z zakresu przewidzianego dla sieci wewnętrznych i jednocześnie różnił się od obecnego adresu komputera fizycznego. Wpiszmy 192.168.13.1 z maską 255.255.255.0. Mając już ustalony adres po stronie komputera fizycznego musimy skonfigurować interfejs sieciowy maszyny wirtualnej. Poleceniem <strong>Start -> Control Panel -> Network Connections -> Local Area Connection -> Properties</strong> otwieramy okno, gdzie zaznaczamy <strong>Internet Protocol (TCP/IP)</strong> i klikamy <strong>Properties</strong>. Tak samo jak na komputerze hoście zaznaczamy opcję <strong>Use the following IP address</strong> i wpisujemy adres 192.168.13.2 z maską 255.255.255.0. Jak widzimy, jedyna różnica jest w ostatniej cyfrze. Jednym słowem mamy dwa komputery, jeden fizyczny a drugi wirtualny, które pracują w jednej sieci 192.168.13.y gdzie y oznacza w naszym przypadku konkretny interfejs. Wywołanie w konsoli komputera hosta polecenia</p><pre><code class=language-dos data-lang=dos>ping 192.168.13.2
</code></pre><p>badającego dostępność karty sieciowej maszyny wirtualnej zwróci nam informacje o niemożności połączenia się. Jest to spowodowane poziomem zabezpieczeń systemu gościa. Aby to zmienić należy poleceniem <strong>Start -> Control Panel -> Windows Firewall</strong> uruchomić okno konfiguracyjne ściany ogniowej maszyny wirtualnej. W zakładce <strong>Advanced</strong> w sekcji <strong>ICMP</strong> klikamy przycisk <strong>Settings</strong>, zaznaczamy opcję <strong>Allow incoming echo request</strong> i zatwierdzamy. Po tych zmianach wywołanie polecenia ping powinno zwrócić informacje o czasie wymiany pakietów pomiędzy konfigurowanymi systemami.</p><figure><img class=pure-img src=https://awasn.github.io/http-wlasny-serwer-komunikacji-cz2-srodowisko-programistyczne/images/ping.png alt="Sprawdzenie dostępności karty sieciowej maszyny wirtualnej"><figcaption><h4>Sprawdzenie dostępności karty sieciowej maszyny wirtualnej</h4></figcaption></figure><p>Jeśli adres istniejącego połączenia sieciowego komputera hosta również jest w formacie 192.168.x.y i x wynosi 13, to aby uniknąć konfliktów z adresacją dwóch sieci karcie Loopback przypiszmy zamiast 13 dowolną inną liczbę np. 14. Aby zorientować się co do przypisanych adresów IP należy uruchomić konsolę systemu komputera rzeczywistego i wpisać polecenie:</p><pre><code class=language-dos data-lang=dos>ipconfig /all
</code></pre><p>Zostaną wówczas wyświetlone wszystkie informacje dotyczące konfiguracji istniejących połączeń sieciowych. Poniższy zrzut ekranu pokazuje konfigurację interfejsów dla maszyny wirtualnej. Mniej więcej podobne informacje, tylko w większej ilości, będą wyświetlone po wydaniu polecenie ipconfig dla komputera rzeczywistego.</p><figure><img class=pure-img src=https://awasn.github.io/http-wlasny-serwer-komunikacji-cz2-srodowisko-programistyczne/images/ipconfig.png alt="Konfiguracja połączeń sieciowych maszyny wirtualnej"><figcaption><h4>Konfiguracja połączeń sieciowych maszyny wirtualnej</h4></figcaption></figure><p>W przypadku WMware Server parametr <strong>Ethernet</strong> maszyny wirtualnej powinien przyjąć wartość <strong>Host-only: A private network shared with host</strong> lub <strong>Custom: Specific virtual network</strong> z wybranym adapterem zawierającym w nazwie host-only np. <strong>VMnet1 (Host-only)</strong>. Ostatni sposób daje też oczywiście więcej możliwości jeśli chodzi o konfigurację działania sieci. Następnie w programie Manage Virtual Networks w zakładce <strong>Summary</strong> sprawdzamy jaki adres przypisany jest do interfejsu odpowiedzialnego za tworzenie sieci prywatnych.</p><figure><img class=pure-img src=https://awasn.github.io/http-wlasny-serwer-komunikacji-cz2-srodowisko-programistyczne/images/Manage_Virtual_Networks_Summary.png alt="Aplikacja Manage Virtual Networks"><figcaption><h4>Aplikacja Manage Virtual Networks</h4></figcaption></figure><p>Kolejny krok to konfiguracja karty sieciowej maszyny wirtualnej. Powyższy zrzut ekranu pokazuje, iż przypisany po stronie komputera fizycznego adres to 192.168.157.0 z maską 255.255.255.0. Podobnie jak w przypadku konfiguracji systemu gościa uruchamianego w ramach Virtual PC, tak i teraz przypisujemy do karty sieciowej maszyny wirtualny adres z tej samej sieci. W tym przypadku 192.168.157.2. Po odblokowaniu ściany ogniowej, możemy korzystając z polecenia ping sprawdzić dostępność systemu gościa.</p><h3 id=internet-information-services>Internet Information Services</h3><p>Domyślnie Windows Server 2003 nie posiada zainstalowanych usług internetowych. Dodanie IIS możemy wykonać na dwa sposoby.</p><p>W pierwszym, po wybraniu <strong>Start -> Control Panel -> Add or Remove Programs -> Add/Remove Windows Components</strong> zaznaczamy <strong>Microsoft .NET Framework 2.0</strong> a w ramach części <strong>Application Server</strong> element <strong>ASP.NET</strong>, który aktywuje wszystkie niezbędne składniki.</p><p>Drugi sposób polega na wybraniu polecenia <strong>Start -> Manage Your Server</strong>. W części <strong>Adding Roles to Your Server</strong> klikamy <strong>Add or remove a role</strong>. Wyświetli nam się okno dialogowe, w których wybieramy <strong>Next</strong> a następnie zaznaczamy opcję <strong>Application Server (IIS, ASP.NET)</strong> i ponownie <strong>Next</strong>. Aktywujemy <strong>ASP.NET</strong> i klikamy dwa razy <strong>Next</strong>. Niestety ta metoda nie instaluje platformy .NET w wersji 2.0 tylko w wersji 1.1. Musimy więc wersję 2.0 tak czy siak jeszcze dodać.</p><p>W czasie instalowania składników system poprosi nas o włożenie do napędu CD-ROM płyt instalacyjnych. Cała niezbędna zawartość znajduje się w katalogu <strong>C:\WindowsInstallationFiles\I386</strong> oraz <strong>C:\Documents and Settings\Administrator\WindowsInstallationFiles\CMPNENTS\R2</strong> maszyny wirtualnej.</p><p>Zanim jednak przystąpimy do sprawdzania, czy poziomu hosta połączymy się z serwerem WWW maszyny wirtualnej warto poinformować ścianę ogniową serwera, iż chcemy zezwolić na dostęp do IIS z zewnątrz. Poleceniem <strong>Start -> Control Panel -> Windows Firewall</strong> uruchamiamy okno konfigurujące. Przechodzimy na zakładkę <strong>Advanced</strong> i w części <strong>Network Connection Settings</strong> klikamy przycisk <strong>Settings&mldr;</strong>. W oknie dialogowym, które się pojawi pozostaje nam zaznaczyć <strong>Web Server (HTTP)</strong> i potwierdzić nasz wybór w kolejnym oknie.</p></article><nav aria-label="Posts in series"><h4>Posts in <a href=https://awasn.github.io/series/serwer-komunikacji>Serwer komunikacji</a> series</h4><ul><li><a href=https://awasn.github.io/http-wlasny-serwer-komunikacji-cz1-wstep/>HTTP - Własny serwer komunikacji. Część #1 - Wstęp</a></li><li><a href=https://awasn.github.io/http-wlasny-serwer-komunikacji-cz2-srodowisko-programistyczne/>HTTP - Własny serwer komunikacji. Część #2 - Środowisko programistyczne</a></li></ul></nav><nav aria-label="Related posts"><h4>Related Posts</h4><ul><li><a href=https://awasn.github.io/http-wlasny-serwer-komunikacji-cz1-wstep/>HTTP - Własny serwer komunikacji. Część #1 - Wstęp</a></li><li><a href=https://awasn.github.io/formsauthentication-w-reporing-services/>FormsAuthentication w Reporing Services</a></li><li><a href=https://awasn.github.io/sql-server-2005-compact-edition/>SQL Server 2005 Compact Edition</a></li><li><a href=https://awasn.github.io/resharper-ostrzega-possible-nullreferenceexception/>ReSharper ostrzega - Possible NullReferenceException</a></li><li><a href=https://awasn.github.io/metoda-fabryki/>Metoda fabryki</a></li></ul></nav><nav class="pure-g post-previous-next" aria-label="Previous and next posts"><div class="pure-u-11-24 previous"><a href=https://awasn.github.io/okreslanie-dnia-tygodnia-z-pogarda-dla-datefirst/ aria-label="Previous post"><span aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-left"><polyline points="15 18 9 12 15 6"/></svg></span></a><a href=https://awasn.github.io/okreslanie-dnia-tygodnia-z-pogarda-dla-datefirst/>Określanie dnia tygodnia z pogardą dla DATEFIRST</a></div><div class=pure-u-2-24>&nbsp;</div><div class="pure-u-11-24 next"><a href=https://awasn.github.io/hook-scripts-w-csharp/>Hook scripts w C#</a>
<a href=https://awasn.github.io/hook-scripts-w-csharp/ aria-label="Next post"><span aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"><polyline points="9 18 15 12 9 6"/></svg></span></a></div></nav></main><footer><div class="center-aligned container"><p>Copyright &copy; 2007-2021 Arkadiusz Waśniewski. All Rights Reserved.</p></div></footer><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/languages/accesslog.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/languages/dockerfile.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/languages/dos.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/languages/powershell.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/languages/routeros.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/languages/typescript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/languages/yaml.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/languages/vbnet.min.js></script><script>hljs.initHighlightingOnLoad()</script></body></html>